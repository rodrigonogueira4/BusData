<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
    <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script>
    <script type="text/javascript" src="d3.v2.js"></script>
    <script type="text/javascript" src="jquery.min.js"></script>
    <style type="text/css">
		html, body {
		  width: 100%;
		  height: 100%;
		  margin: 0;
		  padding: 0;
		}

		#map {
		  width: 100%;
		  height:800px;
		  margin: 0;
		  padding: 0;
		}
		.rawpt, .rawpt svg {
		  position: absolute;
		}

		.rawpt svg {
		  width: 60px;
		  height: 20px;
		  padding-right: 100px;
		  font: 10px sans-serif;
          z-index: 1;
		}

		.rawpt circle {
		  fill: blue;
		  opacity: 0.4;
		}

		.outliers, .outliers svg {
		  position: absolute;
		}

		.outliers svg {
		  width: 1000px;
		  height: 1000px;
		  padding-right: 100px;
		  font: 10px sans-serif;
          z-index: 2;
		}

		.outliers circle {
		  fill: red;
		  stroke: black;
		  stroke-width: 0.2px;
		}
		.axis path {
			fill: none;
			stroke: #777;
			shape-rendering: crispEdges;
		}
		.axis text {
			font-family: Lato;
			font-size: 13px;
		}

		.barchart rect {
			fill: steelblue;
		}

		.barchart text {
			fill: white;
			font: 10px sans-serif;
			text-anchor: end;
		}
		
		.barchartDiv {
			float: left;
			overflow-y: scroll;
			height: 800px;
			width: 300px;
		}
		
		.verticalBarchartDiv {
			overflow-x: scroll;
			height: 200px;
			width: 1263px;
		}

		.verticalBarchart rect {
			fill: limegreen;
		}

		.verticalBarchart text {
			fill: black;
			font: 10px sans-serif;
			text-anchor: end;
		}

		.axis path {
			fill: none;
			stroke: #777;
			shape-rendering: crispEdges;
		}
		.axis text {
			font-family: Lato;
			font-size: 13px;
		}

	</style>
	</head>
	<body>
			<div id="dayChart" class="verticalBarchartDiv">
				<svg class="verticalBarchart"></svg>
			</div>

		<table>
		<tr>
		  <td><center>Start Time</center></td>
		  <td><center>Time Window</center></td>
            <td><input type="checkbox" id="SetEndPts" value="SetEndPtsValue" >Set End Points<br></td>
		</tr>
		<tr>
		  <td><input id="inputStartTime" type="range"  min="0" max="1439" value = "0" onchange="loadPts()"/></td>
		  <td><input id="inputTimeRange" type="range"  min="0" max="1439" value = "1439" onchange="loadPts()"/></td>
          <td><input type="checkbox" id="ConnectedPts" value="ConnectedPtsValue" onchange="loadPts()" checked>Connected Points<br></td>
		</tr>
		<tr>
		  <td><center id="valueStartTime"></center></td>
		  <td><center id="valueTimeRange"></center></td>
		</tr>
		</table>
        
		<div style="width: 100%; height: 800px; overflow: hidden;">
			<div class="barchartDiv">
				<svg class="barchart"></svg>
			</div>
			<!--<div style="width: 100px; float: left;"> Lines<br>
				<select id = "lstbox_lines"
					onChange="loadPts()"
					multiple = "multiple"
					size = "30">
				  </select>
			</div>-->
			<div style="margin-left: 300px;"> <div id="map"></div> </div>
		</div>
		<div class="container">
			<div class="jumbotron">
				<svg id="visualisation" width="1000" height="500"></svg>
			</div>
		</div>
	</body>

	<script type="text/javascript">
		var maxPts = 1000;
		var outliersfile = "5_12.csv";
		var outliersperdayfile = "number_of_outliers_per_day.csv";
		var dateFile = "5-12-2013";
		var startHour;
		var startMinute;
		var rangeHour;
		var rangeMinute;
		var selectedOutlier;
		var MAX_DIST = (0.001); //maximum distance to 2 pts be considered close. 1 degree latitude = 100km. 1 meter = 0.00001 degrees. 100 meters = 0.001
		var RIO_CENTER_LAT = -22.911773;
		var RIO_CENTER_LONG = -43.230199;
		var overlay_outliers = new google.maps.OverlayView();
		var outlier_data;
		var outlier_data_layer;
		var overlay_raw = new google.maps.OverlayView();
		var raw_data;
		var raw_data_layer;
		var raw_data_load_callback_count;
		var selectedLines;
		var min_latitude_bounding = null;
		var max_latitude_bounding = null;
		var min_longitude_bounding = null;
		var max_longitude_bounding = null;
    </script>
    
	<script type="text/javascript">
    
		var vis = d3.select("#visualisation"),
            WIDTH = 1000,
            HEIGHT = 500,
            MARGINS = {
                top: 20,
                right: 20,
                bottom: 60,
                left: 80
            },
			xScale = d3.scale.linear().range([MARGINS.left, WIDTH - MARGINS.right]).domain([0.0, 1.0]),
			//xScale = d3.time.scale().range([MARGINS.left, WIDTH - MARGINS.right]),
            yScale = d3.scale.linear().range([HEIGHT - MARGINS.top, MARGINS.bottom]).domain([-0.05, 0.4]),
            xAxis = d3.svg.axis()
					  .scale(xScale),
                      //.tickFormat(d3.time.format("%H:%m")),
			yAxis = d3.svg.axis()
					  .scale(yScale)
					  .orient("left");
    
		vis.append("svg:g")
		   .attr("class","axis")
		   .attr("transform", "translate(0," + (HEIGHT - MARGINS.bottom) + ")")
		   .call(xAxis);
		vis.append("svg:g")
		   .attr("class","axis")
           .attr("transform", "translate(" + (MARGINS.left) + ", " + (0) + ")")
           .call(yAxis);
        
		//Create X axis label   
		vis.append("svg:text")
		.attr("x", WIDTH / 2 )
        .attr("y",  HEIGHT )
        .style("text-anchor", "middle")
        .text("Time");
    
        //Create Y axis label
        vis.append("svg:text")
        .attr("transform", "rotate(-90)")
        .attr("y", 10)
        .attr("x",0 - (HEIGHT / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("Distance"); 
        
		var lineGenOutlier = d3.svg.line()
							   .x(function(d) {
								   var ts = new Date(d.TimeStamp.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var startTime= new Date(d.TimeStampStart.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var endTime = new Date(d.TimeStampEnd.substring(0, 19).replace(" ", "T")+ "+0000");
                                   //return xScale(d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 15:36:03"))
                                   return xScale((ts - startTime)/(endTime-startTime));
							   })
							   .y(function(d) {
									return yScale(Math.abs(+d.LatitudePonto - selectedOutlier.LatitudePonto ) + Math.abs(+d.LongitudePonto - selectedOutlier.LongitudePonto ));
							   })
							   .interpolate("basis");
    
		var lineGenRawPts = d3.svg.line()
							  .x(function(d) {
									var ts = new Date(d[11].substring(0, 19).replace(" ", "T")+ "+0000");
                                    var startTime= new Date(d.TimeStampStart.substring(0, 19).replace(" ", "T")+ "+0000");
                                    var endTime = new Date(d.TimeStampEnd.substring(0, 19).replace(" ", "T")+ "+0000");
									//return xScale(d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 15:36:03"))
                                    return xScale((ts - startTime)/(endTime-startTime));
							  })
							  .y(function(d) {
									return yScale(Math.abs(+d[9] - selectedOutlier.LatitudePonto) + Math.abs(+d[10] - selectedOutlier.LongitudePonto ));
							  })
							  .interpolate("basis");
        
	    //MOD THIS
        //xScale.domain(d3.extent(data, function(d) { return d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 15:36:03"); }));
        //xScale.domain([d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 09:36:03"),d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 11:36:03")]);
    
		function parseDate(datestr) {
			return Date.parse(datestr.substring(0, 19).replace(" ", "T"));
		}
		// Create the Google Map
        var stylez = [
            {
              featureType: "all",
              elementType: "all",
              stylers: [
                { saturation: -100 } // <-- THIS SETS TO GRAYSCALE
              ]
            }
        ];

        var mapOptions = {
            zoom: 9,
            center: new google.maps.LatLng(RIO_CENTER_LAT, RIO_CENTER_LONG),
            mapTypeControlOptions: {
                 mapTypeIds: [google.maps.MapTypeId.ROADMAP, 'tehgrayz']
            },
        };

        map = new google.maps.Map(d3.select("#map").node(), mapOptions);
        var mapType = new google.maps.StyledMapType(stylez, { name:"Grayscale" });    
        map.mapTypes.set('tehgrayz', mapType);
        map.setMapTypeId('tehgrayz');

		//var map = new google.maps.Map(d3.select("#map").node(), {
		//	zoom: 9,
		//	center: new google.maps.LatLng(RIO_CENTER_LAT, RIO_CENTER_LONG),
		//	//mapTypeId: google.maps.MapTypeId.TERRAIN
		//});
    
		// Load the raw data. When the data comes back, create an overlay.		
		overlay_raw.onAdd = function() {
			raw_data_layer = d3.select(this.getPanes().overlayMouseTarget).append("div")
																		  .attr("class", "rawpt");
			// Draw each marker as a separate SVG element.
			// We could use a single SVG, but what size would it have?
		};
		overlay_raw.draw = function() {
			var projection = this.getProjection(),
			padding = 10;

			var marker = raw_data_layer.selectAll("svg")
							  .data(d3.entries(raw_data))
							  .each(transform) // update existing markers
							  .enter().append("svg:svg")
							  .each(transform)
							  .attr("class", "marker");

			// Add a circle.
			marker.append("svg:circle")
				  .attr("r", 3.0)
				  .attr("cx", padding)
				  .attr("cy", padding);

			function transform(d) {
				d2 = new google.maps.LatLng(+d.value[9], +d.value[10]);
				//d2 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
				d2 = projection.fromLatLngToDivPixel(d2);
				return d3.select(this)
						 .style("left", (d2.x - padding) + "px")
						 .style("top", (d2.y - padding) + "px");
			}
		};
		overlay_raw.onRemove = function() {
			$(".rawpt").remove();
		};
        
		function loadPtsRaw() {
			overlay_raw.setMap(null);
			raw_data = null;
			raw_data_load_callback_count = selectedLines.length;

			for (i=0; i < selectedLines.length; i++) {
				d3.text("data_separated_by_line_and_day/"+selectedLines[i]+"/" + dateFile, function(text) {

					raw_data = d3.csv.parseRows(text);
					
					//do sampling
					var samplingRate = Math.floor(raw_data.length/maxPts);
					if (samplingRate < 1) {
						samplingRate = 1;
					}
					raw_data = raw_data.filter(function(row,index) { 
						if (index % samplingRate != 0) {
							return false;
						}
						return true;
					});
					
					//filter by start date
					raw_data = raw_data.filter(function(row,index) {
						var ts = new Date(row[11].substring(0, 19).replace(" ", "T")+ "+0000");
						
						if (startHour > +ts.getUTCHours()) {
							return false;
						}
						else if (startHour == +ts.getUTCHours()) {
						   if (startMinute > +ts.getUTCMinutes()) {
							   return false;
						   }
						}
						
						if (startHour + rangeHour < +ts.getUTCHours()) {
							return false;
						}
						else if (startHour + rangeHour == +ts.getUTCHours()) {
						   if (startMinute +rangeMinute < +ts.getUTCMinutes()) {
							   return false;
						   }
						}
						
						return true;
					});   
	
					//select buses for temporal chart comparison. Select buses that are close to the start point of the outlier
					if (selectedOutlier != null)
					{
						selectedBuses = {}
						for (idx in raw_data){
							var dist = Math.pow(Math.pow(+raw_data[idx][9] - selectedOutlier.LatitudePonto,2) + Math.pow(+raw_data[idx][10] - selectedOutlier.LongitudePonto, 2), 0.5);
							if (dist < MAX_DIST){
								selectedBuses[raw_data[idx][3]] = 1; //dic[<busid] = timestamp
							}
						}
						//filter by start date and end date of the outlier
						data2 = {}; 
						var startTime = new Date(selectedOutlier.TimeStampStart.substring(0, 19).replace(" ", "T") + "+0000");
						var endTime = new Date(selectedOutlier.TimeStampEnd.substring(0, 19).replace(" ", "T") + "+0000");

						for (idx in raw_data) {
							if (min_latitude_bounding == null || min_latitude_bounding > raw_data[idx][9])
								min_latitude_bounding = raw_data[idx][9];
							if (max_latitude_bounding == null || max_latitude_bounding < raw_data[idx][9])
								max_latitude_bounding = raw_data[idx][9];
							if (min_longitude_bounding == null || min_longitude_bounding > raw_data[idx][10])
								min_longitude_bounding = raw_data[idx][10];
							if (max_longitude_bounding == null || max_longitude_bounding < raw_data[idx][10])
								max_longitude_bounding = raw_data[idx][10];
								
							if (!(raw_data[idx][3] in selectedBuses)) {
								continue;
							}
							var ts = new Date(raw_data[idx][11].substring(0, 19).replace(" ", "T") + "+0000");
						  
							if(+startTime.getUTCHours() > +ts.getUTCHours()) {
								continue;
							}
							else if (+startTime.getUTCHours() == +ts.getUTCHours()) {
								if (+startTime.getUTCMinutes() > +ts.getUTCMinutes()) {
									continue;
								}
							}
							
							if(+endTime.getUTCHours() < +ts.getUTCHours()) {
								continue;
							}
							else if (+endTime.getUTCHours() == +ts.getUTCHours()) {
								if (+endTime.getUTCMinutes() < +ts.getUTCMinutes()) {
									continue;
								}
							}
							if (!(raw_data[idx][3] in data2)) {
								data2[raw_data[idx][3]] = []
							}
							data2[raw_data[idx][3]].push(raw_data[idx]);
						}
					}

					//add to the temporal chart
					/*for (var key in data2) {
						vis.append('svg:path')
						   .attr('d', lineGenRawPts(data2[key]))
						   .attr('stroke', 'blue')
						   .attr('stroke-width', 1)
						   .attr("class", "line")
						   .attr('fill', 'none');
					}*/	
                    raw_data_load_callback();
					//var overlay_raw = new google.maps.OverlayView();
					// Add the container when the overlay is added to the map.
					// Bind our overlay to the map…
				});
			}
			//overlay_raw.draw();
		}
		//var rectangle;
		var bounds = new google.maps.LatLngBounds();
		function raw_data_load_callback() {
			raw_data_load_callback_count = raw_data_load_callback_count - 1;
			if (raw_data_load_callback_count == 0)
				overlay_raw.setMap(map);
			
			bounds = new google.maps.LatLngBounds();
			bounds.extend(new google.maps.LatLng(+max_latitude_bounding, +max_longitude_bounding));
			bounds.extend(new google.maps.LatLng(+min_latitude_bounding, +min_longitude_bounding));
			map.setCenter(new google.maps.LatLng((+min_latitude_bounding + +max_latitude_bounding)/2, (+min_longitude_bounding + +max_longitude_bounding)/2));
			map.fitBounds(bounds);
			/*if (rectangle != null)
				rectangle.setMap(null);
			rectangle = new google.maps.Rectangle({
				strokeColor: '#FF0000',
				strokeOpacity: 0.8,
				strokeWeight: 2,
				fillColor: '#FF0000',
				fillOpacity: 0.35,
				map: map,
				bounds: new google.maps.LatLngBounds(
					new google.maps.LatLng(max_latitude_bounding, max_longitude_bounding),
					new google.maps.LatLng(min_latitude_bounding, min_longitude_bounding))
			});*/
		}
		
		overlay_outliers.onAdd = function() {
			//remove all previous layers.
			myNode = this.getPanes().overlayMouseTarget;
			while (myNode.firstChild) {
				myNode.removeChild(myNode.firstChild);
			}

			outlier_data_layer = d3.select(this.getPanes().overlayMouseTarget).append("div")
																 .attr("class", "outliers");
		};
		overlay_outliers.draw = function() {
			var projection = this.getProjection(),
			padding = 10;
			
			var tooltip = d3.select("body")
							.append("div")
							.style("position", "absolute")
							.style("z-index", "10")
							.style("visibility", "hidden")
							.text("a simple tooltip");
            
            var marker = outlier_data_layer.selectAll("svg")
										   .data(d3.entries(outlier_data))
										   .each(
											  function (d) {
												d = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
												d = projection.fromLatLngToDivPixel(d);
												return d3.select(this)
												  .style("left", (d.x - padding) + "px")
												  .style("top", (d.y - padding) + "px");
											  }
										   )
										   .enter().append("svg:svg")
										   .each(
											  function (d) {
												d = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
												d = projection.fromLatLngToDivPixel(d);
												return d3.select(this)
												  .style("left", (d.x - padding) + "px")
												  .style("top", (d.y - padding) + "px")
											  }
										   )
										   .attr("class", "marker");

			// Add a circle.
			marker.append("svg:circle")
				  //.attr("r", function(d) { return (3.0 + 5.0 * d.value['TimeStampPercentage']) })
				  .attr("r", 6.0)
				  .attr("cx", padding)
				  .attr("cy", padding)
				  .on("click", function(d, i) {
					  tooltip.style("visibility", "visible");
                      alert("Selected node:\n" +
                            "Start: " + d.value['TimeStampStart'] + "\n"+
                            "End:   " + d.value['TimeStampEnd'] + "\n"+
                            "Line: " + d.value['Line'] + "\n"+
                            "Bus Id: " + d.value['BusId']);					  
				  });
            
			//Add a label.
			/*marker.append("svg:text")
				  .attr("x", padding + 7)
				  .attr("y", padding)
				  .attr("dy", ".31em")
				  .text(function(d) { 
							//if (selectedLines[0] =="All") {
							//	return d.value['Line'];
							//}
							//else{
						    //return d.value['row'];
                            //}
								return "";
						});*/
            
            if ($('#ConnectedPts').is(':checked') && (selectedLines[0] != "All")){
                //remove all lines
                $(".marker2").remove();
                var marker = outlier_data_layer.selectAll("svg2")
                                               .data(d3.entries(outlier_data))
                                               .each(
                                                  function (d) {
                                                    d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                    d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     var minx = Math.min(d1.x, d2.x);
                                                     var miny = Math.min(d1.y, d2.y);
                                                    return d3.select(this)
                                                      .style("left", (minx) + "px")
                                                      .style("top", (miny) + "px");
                                                  }
                                               )
                                               .enter().append("svg:svg")
                                               .each(
                                                  function (d) {
                                                    d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                    d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     var minx = Math.min(d1.x, d2.x);
                                                     var miny = Math.min(d1.y, d2.y);
                                                    return d3.select(this)
                                                      .style("left", (minx) + "px")
                                                      .style("top", (miny) + "px");
                                                  }
                                               )
                                               .attr("class", "marker2");
                marker.append("svg:line")
                      .style("stroke", "red") 
                      .style("stroke-width", 2) 
                      .attr("x1", 0)
                      .attr("y1", function (d) {     d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                    d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     if (d1.x>d2.x){
                                                         return d2.y - Math.min(d1.y,d2.y);
                                                     }else{
                                                         return d1.y - Math.min(d1.y,d2.y);
                                                     }
                                                  })
                      .attr("x2", function (d) {     d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                    d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     var minx = Math.min(d1.x, d2.x);
                                                     var maxx = Math.max(d1.x, d2.x);
                                                    return maxx-minx;
                                                  })
                      .attr("y2", function (d) {     d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                    d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     if (d1.x>d2.x){
                                                         return d1.y - Math.min(d1.y,d2.y);
                                                     }else{
                                                         return d2.y - Math.min(d1.y,d2.y);
                                                     }
                                                  });
            }
		};
    
		overlay_outliers.onRemove = function() {
			$(".outliers").remove();
		};

		function loadOutliersPerDay() {
			var barchart_data = [];
			d3.csv(outliersperdayfile, function(data) {
				data.forEach(function(d) {
					barchart_data.push({key: d.Date, number_of_outliers: d.NumberOfOutliers});
				});

				var barWidth = 40;
				var height = 179;

				var y = d3.scale.linear()
					.domain([0, d3.max(barchart_data, function(d) { return d.number_of_outliers*1.05; })])
					.range([0, height]);

				var chart = d3.select(".verticalBarchart")
								.attr("width", barWidth * barchart_data.length)
								.attr("height", height);

				var bar = chart.selectAll("g")
								.data(barchart_data)
								.enter().append("g")
								.attr("transform", function(d, i) { return "translate(" + i * barWidth + "," + (height - y(d.number_of_outliers)) + ")"; });

				bar.append("rect")
					.attr("height",  function(d) { return y(d.number_of_outliers); })
					.attr("width", barWidth - 1)
					.on("click", function(d, i) {
									d3.select(".vselected").style({fill: "limegreen"});
									d3.select(".vselected").classed("vselected", false);
									d3.select(this).classed("vselected", true);
									d3.select(this).style({fill: 'red'});
                  fields = d.key.split("/");
									dateFile = fields[1] + "-" + fields[0] + "-2013";
                  outliersfile = fields[1] + "_" + fields[0] + ".csv";
									loadLstboxFromOutliers();
								 })
					.on("mouseover", function(d, i) {
										d3.select(this).style({opacity: '0.6'});
										})
					.on("mouseout", function(d, i) {
										d3.select(this).style({opacity: '1.0'});
									 });

				bar.append("text")
					.attr("x", barWidth / 2)
					.attr("y", function (d) { y(d.number_of_outliers); })
					.attr("dx", "1em")
					.attr("transform", function(d) { return "translate(0, " + (y(d.number_of_outliers) - 3) + ")"; })
					.text(function(d) { return d.key; })
					.on("click", function(d, i) {
                  fields = d.key.split("/");
									dateFile = fields[1] + "-" + fields[0] +  "-2013";
                  outliersfile = fields[1] + "_" + fields[0] + ".csv";
									loadLstboxFromOutliers();
								 });

				
				bar.append("text")
					.attr("x", barWidth / 2)
					.attr("y", function (d) { y(d.number_of_outliers); })
					.attr("dx", ".8em")
					//.attr("transform", function(d) { return "translate(0, " + 12 + ")"; })
					.text(function(d) { return d.number_of_outliers; })
					.on("click", function(d, i) {
                  fields = d.key.split("/");
									dateFile = fields[1] + "-" + fields[0] + "-2013";
                  outliersfile = fields[1] + "_" + fields[0] + ".csv";
									loadLstboxFromOutliers();
								 });

			});
		}
			
		function loadPtsOutliers() {
			overlay_outliers.setMap(null);
			outlier_data = null;
			
			min_latitude_bounding = null;
			max_latitude_bounding = null;
			min_longitude_bounding = null;
			max_longitude_bounding = null;

			d3.csv(outliersfile, function(data) {
				data = data.filter(function(row,index) {
					var contains = false;
					for (i in selectedLines) {
						if (row['Linha'] == selectedLines[i]) {
							contains = true;
						}
						if (selectedLines[i] == "All") {
							contains = true;
						}
					}
					
					return contains;
				});
			
				outlier_data = [];
				var lines_outliers = {};  
				k = 0;
				//pts must be structured as rows
				for (row in data) {
					var minreftime = parseDate(data[row]['TimeStamp_19']); 
					var maxreftime = parseDate(data[row]['TimeStamp_0']); 
                    console.log("starttime: " + data[row]['TimeStamp_19']);
                    console.log("endtime: " + data[row]['TimeStamp_0']);
                    
					for (i = 0; i<20; i++){
						var timestamp = parseDate(data[row]['TimeStamp_' + i]);
                        //console.log("time " + i + ":" + data[row]['TimeStamp_'+i]);
                      
                        if (i>=1){
                            var TimeStampPrevious = data[row]['TimeStamp_'+(i-1)];
                            var LatPrevious = data[row]['LatitudePonto_'+(i-1)];
                            var LongPrevious = data[row]['LongitudePonto_'+(i-1)];
                        }else{
                            var TimeStampPrevious = data[row]['TimeStamp_'+i];
                            var LatPrevious = data[row]['LatitudePonto_'+i];
                            var LongPrevious = data[row]['LongitudePonto_'+i];
                        }
						outlier_data[k] = {
							TimeStampPercentage: (timestamp - minreftime) / (maxreftime-minreftime), 
							TimeStampStart:data[row]['TimeStamp_19'].substring(0, 19),
							TimeStampEnd:data[row]['TimeStamp_0'].substring(0, 19),
							TimeStamp:data[row]['TimeStamp_'+i],
							LatitudePonto:data[row]['LatitudePonto_'+i],
							LongitudePonto:data[row]['LongitudePonto_'+i],
                             TimeStampPrevious: TimeStampPrevious,
							LatitudePontoPrevious:LatPrevious,
							LongitudePontoPrevious:LongPrevious,
							row:row,
							BusId:data[row]["Onibus"],
							Line:data[row]["Linha"]
						};
						if (min_latitude_bounding == null || min_latitude_bounding > outlier_data[k]['LatitudePonto'])
							min_latitude_bounding = outlier_data[k]['LatitudePonto'];
						if (max_latitude_bounding == null || max_latitude_bounding < outlier_data[k]['LatitudePonto'])
							max_latitude_bounding = outlier_data[k]['LatitudePonto'];
						if (min_longitude_bounding == null || min_longitude_bounding > outlier_data[k]['LongitudePonto'])
							min_longitude_bounding = outlier_data[k]['LongitudePonto'];
						if (max_longitude_bounding == null || max_longitude_bounding < outlier_data[k]['LongitudePonto'])
							max_longitude_bounding = outlier_data[k]['LongitudePonto'];
						k = k + 1;
					} 
				}
		   
				//do sampling
				var samplingRate = Math.floor(outlier_data.length/maxPts);

				if (samplingRate < 1){
					samplingRate = 1;
				}
				outlier_data = outlier_data.filter(function(row,index) { 
					if (index % samplingRate != 0) {
						return false;
					}
					return true;
				}); 
			
				//filter by start date
				outlier_data = outlier_data.filter(function(row,index) {
					var ts = new Date(row["TimeStamp"].substring(0, 19).replace(" ", "T")+ "+0000");
					if (startHour > +ts.getUTCHours()) {
						return false;
					}
					else if (startHour == +ts.getUTCHours()) {
						if (startMinute > +ts.getUTCMinutes()) {
							return false;
						}
					}
					
					if(startHour + rangeHour < +ts.getUTCHours()) {
						return false;
					}
					else if (startHour + rangeHour == +ts.getUTCHours()) {
					   if (startMinute +rangeMinute < +ts.getUTCMinutes()) {
						   return false;
					   }
					}
					return true;
				});
                
                selectedOutlier = outlier_data[0]; //set the selected outlier var with the first point of the first outlier. Its timestamp and coordinates will be used so select raw points in the temporal chart
             
                //remove duplicated outliers
                outlier_data_by_bus = {};
                outlier_data_by_bus2 = {};
                for (row in outlier_data) {
                    //if (outlier_data[row]["BusId"] != selectedOutlier["BusId"]){
                    //    continue;
                    //}
                    if (!((outlier_data[row]["BusId"]+outlier_data[row]["TimeStamp"]) in outlier_data_by_bus)){
                          outlier_data_by_bus[outlier_data[row]["BusId"]+outlier_data[row]["TimeStamp"]] = 1;
                          if (!(outlier_data[row]["BusId"] in outlier_data_by_bus2)){
                              outlier_data_by_bus2[outlier_data[row]["BusId"]] = [];
                          }
                          outlier_data_by_bus2[outlier_data[row]["BusId"]].push(outlier_data[row]);
                        
                          //update start and end dates of the selected outlier
                          //var startTime = new Date(selectedOutlier.TimeStampStart.substring(0, 19).replace(" ", "T")+ "+0000");
                          //var endTime = new Date(selectedOutlier.TimeStampEnd.substring(0, 19).replace(" ", "T")+ "+0000");
                          //var ts= new Date(outlier_data[row]["TimeStamp"].substring(0, 19).replace(" ", "T")+ "+0000");
                          //if (ts < startTime){
                          //    selectedOutlier.TimeStampStart = outlier_data[row]["TimeStamp"];
                          //}
                          //if (ts > endTime){
                          //    selectedOutlier.TimeStampEnd = outlier_data[row]["TimeStamp"];
                          //}
                    }
				}
                
          		//add to the temporal chart
                /*for (key in outlier_data_by_bus2){
                    vis.append('svg:path')
                      .attr('d', lineGenOutlier(outlier_data_by_bus2[key]))
                      .attr('stroke', 'red')
                      .attr('stroke-width', 3)
                      .attr("class", "line")
                      .attr('fill', 'none');
                }*/
				overlay_outliers.setMap(map);
			});
		}
	 
		function loadLstboxFromOutliers() {
			d3.csv(outliersfile, function(data) {
				var data2 = [];
				var lines_outliers = {};
				var lines_outliers_total = {};
				for (row in data){
					if (!(+data[row]['Linha'] in lines_outliers)) {
						lines_outliers[data[row]['Linha']] = {};
					}                                                                                                                                                                                                

          lines_outliers[+data[row]['Linha']][data[row]['Onibus']] = 1; //add bus
					lines_outliers_total[(+data[row]['Linha']) + "_" + data[row]['Onibus']] = 1;
				}
				
				var barchart_data = [];
				var max = 0;
        
        for (line in lines_outliers)
				{
        	barchart_data.push({key: line, number_of_outliers: Object.keys(lines_outliers[line]).length});
					if (Object.keys(lines_outliers[line]).length > max)
						max = Object.keys(lines_outliers[line]).length;
				}
        
				//add "All"
				var width = 280,//420
					barHeight = 20;

				var x = d3.scale.linear()
					.domain([0, d3.max(barchart_data, function(d) { return d.number_of_outliers; })])
					.range([0, width]);

				var chart = d3.select(".barchart")
					.attr("width", width)
					.attr("height", barHeight * barchart_data.length);

				var bar = chart.selectAll("g")
					.data(barchart_data)
				  .enter().append("g")
					.attr("transform", function(d, i) { return "translate(0," + i * barHeight + ")"; });

				bar.append("rect")
					.attr("width",  function(d) { return x(d.number_of_outliers); })
					.attr("height", barHeight - 1)
					.on("click", function(d, i) {
									d3.select(".selected").style({fill: "steelblue"});
									d3.select(".selected").classed("selected", false);

									d3.select(this).classed("selected", true);
									d3.select(this).style({fill: 'red'});
									selectedLines = [d.key];
									loadPts();
								 })
					.on("mouseover", function(d, i) {
										d3.select(this).style({opacity: '0.6'});
										})
					.on("mouseout", function(d, i) {
										d3.select(this).style({opacity: '1.0'});
									 });

				bar.append("text")
					.attr("x", function(d) { return (d.key).length * 5.5 + 1; })
					.attr("y", barHeight / 2)
					.attr("dy", ".35em")
					.text(function(d) { return d.key; })
					.on("click", function(d, i) {
									selectedLines = [d.key];
									console.log(d.key);
									loadPts();
								 });

				
				bar.append("text")
					.attr("x", function(d) { return x(d.number_of_outliers) - 3; })
					.attr("y", barHeight / 2)
					.attr("dy", ".35em")
					.text(function(d) { return d.number_of_outliers; })
					.on("click", function(d, i) {
									selectedLines = [d.key];
									console.log(d.key);
									loadPts();
								 });
									
			});
		}
		function format2digits(n){
            return n > 9 ? "" + n: "0" + n;
        }
		function loadPts() {
			var lstbox = document.getElementById("lstbox_lines");
			//remove all existing lines in the temporal chart
			vis.selectAll("path.line").remove();
            $(".marker2").remove();

			var startTime = document.getElementById("inputStartTime").value;
			startHour = Math.floor(startTime/60);
			startMinute = (startTime%60)
			document.getElementById("valueStartTime").innerHTML = format2digits(startHour) + ":" + format2digits(startMinute);

			var timeRange = document.getElementById("inputTimeRange").value;
			rangeHour = Math.floor(timeRange/60);
			rangeMinute = (timeRange%60)
			document.getElementById("valueTimeRange").innerHTML = format2digits(rangeHour) + ":" + format2digits(rangeMinute);

			loadPtsOutliers();
			loadPtsRaw();	  
		}
		loadOutliersPerDay();
		loadLstboxFromOutliers();
    </script>
</html>
