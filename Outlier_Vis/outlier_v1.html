<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
    <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script>
    <script type="text/javascript" src="d3.v2.js"></script>
    <script type="text/javascript" src="jquery.min.js"></script>
    
    <!--<script type="text/javascript" src="jquery-ui-1.11.1.js"></script>   
    <script type="text/javascript" src="jquery-ui.multidatespicker.js"></script>
    <link rel="stylesheet" type="text/css" href="mdp.css">-->
      
      
    <link rel="stylesheet" type="text/css" href="jquery.datepick.css"> 
    <script type="text/javascript" src="jquery.plugin.js"></script> 
    <script type="text/javascript" src="jquery.datepick.min.js"></script>
      
    <script src=drawlib1.js></script>
    <style type="text/css">
		html, body {
		  width: 100%;
		  height: 100%;
		  margin: 0;
		  padding: 0;
		}

		#map {
		  width: 100%;
		  height:700px;
		  margin: 0;
		  padding: 0;
		}
		.rawpt, .rawpt svg {
		  position: absolute;
		}

		.rawpt svg {
		  width: 60px;
		  height: 20px;
		  padding-right: 100px;
		  font: 10px sans-serif;
          z-index: 2;
		}

		.rawpt circle {
		  fill: blue;
		  opacity: 0.4;
		}

		.outliers, .outliers svg {
		  position: absolute;
		}

		.outliers svg {
		  width: 1000px;
		  height: 1000px;
		  padding-right: 100px;
		  font: 10px sans-serif;
          z-index: 3;
		}

		.connectionline {
          z-index: 1;
          stroke: red;
          stroke-width: 1;
		}
		.outliers circle {
		  fill: red;
		  stroke: black;
		  stroke-width: 0.2px;
		}
		.axis path {
			fill: none;
			stroke: #777;
			shape-rendering: crispEdges;
		}
		.axis text {
			font-family: Lato;
			font-size: 13px;
		}

		.barchart rect {
			fill: steelblue;
		}

		.barchart text {
			fill: white;
			font: 10px sans-serif;
			text-anchor: end;
		}
		
		.sortLineBarChartDiv {
			position: fixed;
			left: 0px;
		}
		
		.barchartDiv {
			float: left;
			overflow-y: scroll;
			height: 580px;
			width: 300px;
		}
		
		.verticalBarchartDiv {
			overflow-x: scroll;
			height: 200px;
			width: 1263px;
		}

		.verticalBarchart rect {
			fill: steelblue;
		}

		.verticalBarchart text {
			fill: black;
			font: 10px sans-serif;
			text-anchor: end;
		}

		.axis path {
			fill: none;
			stroke: #777;
			shape-rendering: crispEdges;
		}
		.axis text {
			font-family: Lato;
			font-size: 13px;
		}
		
		#sortLineBarChartDiv {
			width: 285px;
			left: 0px;
		}
		
		#busesOfLine {
			float: left;

			overflow-y: scroll;
			width: 100px;
			height: 580px;
			
			cursor: default;
			
			margin: 0;
		}

        #outlierinfo {
            border-radius: 25px;
            border: 2px solid #8AC007;
            padding: 20px; 
            width: 200px;
            height: 150px; 
        }		

		#canvastime {
			border: 2px solid black;
		}
		#hideDayBarChart {
			position: relative;
			top: 0;
			left: 0;

			height: 18px;
			width: 18px;
			
			background: steelblue;
			color: white;
			
			border: 1px solid black;
			padding-left: 1px;
			padding-right: 1px;
			
			text-align: center;
			
			cursor: default;
		}
		
	</style>
	</head>
	<body>
        <div style="width: 100%;height: 80px;"><center><font size="8">RioBusData</font><br><font size="4">Visualization of Outlier Buses in the City Rio de Janeiro</font></center></div>
		<div id="hideDayBarChart"><</div>
        <div id="timedatediv"><br>   
        <center><div id="multiInlinePicker" ></div></center>
        <!--<div id="full-year" class="box"></div>-->

        <center><div id="dayChart" class="verticalBarchartDiv">
            <svg class="verticalBarchart"></svg>
        </div></center>
        <br>
        <center><div id="timefilter"><font id="valStartTime"></font><canvas id="canvastime" width="800" height="30"></canvas><font id="valEndTime"></font></div></center>
        </div>
        <br>
        <!--<input type="checkbox" id="ConnectedPts" value="ConnectedPtsValue" onchange="loadPts()" checked>Connected Points<br>-->
        
        
		<div style="width: 100%; height: 600px; overflow: hidden;">
            <div id="sortLineBarChartDiv"><button type="button" id="btnSort" style="width:285px;" onclick="changeSortLineBarChart()">Sort by number of outliers</button></div>
			<!--<div id="sortLineBarChartDiv"><input type="checkbox" id="sortLineBarChart" onchange="changeSortLineBarChart()">Sort by # of Outliers</input></div>-->
			<div class="barchartDiv">
				<svg class="barchart"></svg>
			</div>
			<div id="busesOfLine"></div>
			<!--<div style="width: 100px; float: left;"> Lines<br>
				<select id = "lstbox_lines"
					onChange="loadPts()"
					multiple = "multiple"
					size = "30">
				  </select>
			</div>-->
			<div style="margin-left: 400px;"> <div id="map" style="height: 600px"></div> </div>
		</div>
        <div style="width: 100%; overflow: hidden;">
            <div style="width: 600px; float: left;">
                <div class="container">
                    <div class="jumbotron">
                        <svg id="visualization" width="1000" height="350"></svg>
                    </div>
                </div>
            </div>
            <div style="margin-left: 1050px;"><br><br><br><br><div style="height: 100px" id="outlierinfo"><div>
        </div>    

<!--     <div class="container"> -->
<!-- 			<div class="jumbotron"> -->
<!-- 				<svg id="speedVisualization" width="1000" height="350"></svg> -->
<!-- 			</div> -->
<!-- 		</div> -->

	</body>

	<script type="text/javascript">
		var maxPts = 2000;
		var outliersfile = "outliers/5_12.csv";
		var outliersperdayfile = "number_of_outliers_per_day.csv";
		var dateFile = "5-12-2013";
		var startHour;
		var startMinute;
		var endHour;
		var endMinute;
		var selectedOutlier;
		var sortLineBarChartByNumberOfOutliers = false;
		var MAX_DIST = (0.003); //maximum distance to 2 pts be considered close. 1 degree latitude = 100km. 1 meter = 0.00001 degrees. 100 meters = 0.001
		var RIO_CENTER_LAT = -22.911773;
		var RIO_CENTER_LONG = -43.230199;
		var listOfOutlierBuses = [];
		var listOfSelectedBuses = [];
		var overlay_outliers = new google.maps.OverlayView();
		var outlier_data;
		var outlier_data_layer;
		var overlay_raw = new google.maps.OverlayView();
		var raw_data;
		var raw_data_layer;
		var raw_data_load_callback_count;
		var selectedLines;
		var min_latitude_bounding = null;
		var max_latitude_bounding = null;
		var min_longitude_bounding = null;
		var max_longitude_bounding = null;
    </script>
    <script type="text/javascript">
        $('#multiInlinePicker').datepick({ 
            multiSelect: 100, monthsToShow: 2, monthsToStep: 1, 
            defaultDate: '12/05/2013', prevText: 'Prev month', nextText: 'Next month'});
        
        $('#multiInlinePicker').click(function() {
            date = $('#multiInlinePicker').datepick('getDate');
            date = date.pop(); //get only the last selected day by now
            day = date.getDate();
            month = date.getMonth() + 1
            year = date.getFullYear()
            console.log(day);
            console.log(month);
            dateFile = day + "-" + month +  "-" + year;
            outliersfile = "outliers/" + day + "_" + month + ".csv";
            loadLstboxFromOutliers();
        })
    </script>   
    <!--<script type="text/javascript">
            
        //load multiday calendar chart
        var today = new Date();
        var y = today.getFullYear();
        var d = today.getDate();
        var m = today.getMonth()+1;
        $('#full-year').multiDatesPicker({
            addDates: [m + '/' + d + '/' + y],
            numberOfMonths: [1,2],
            defaultDate: m + '/' + d + '/' + y

        });
    </script>-->
	<script type="text/javascript">
    
    //Speed Chart
    var speedVis = d3.select("#speedVisualization"),
            WIDTH = 1000,
            HEIGHT = 300,
            MARGINS = {
                top: 20,
                right: 20,
                bottom: 20,
                left: 80
            },
			xScale = d3.scale.linear().range([MARGINS.left, WIDTH - MARGINS.right]).domain([0.0, 1.0]),
			yScale = d3.scale.linear().range([HEIGHT - MARGINS.top, MARGINS.bottom]).domain([-0.0, 0.4]),
      xAxis = d3.svg.axis().scale(xScale),
     	yAxis = d3.svg.axis()
					  .scale(yScale)
					  .orient("left");
    
    //Create axes
    speedVis.append("svg:g")
		   .attr("class","axis")
		   .attr("transform", "translate(0," + (HEIGHT - MARGINS.bottom) + ")")
		   .call(xAxis);
		speedVis.append("svg:g")
		   .attr("class","axis")
       .attr("transform", "translate(" + (MARGINS.left) + ", " + (0) + ")")
       .call(yAxis);
    
 
		//Create X label for speed chart   
		speedVis.append("svg:text")
		    .attr("x", WIDTH / 2 )
        .attr("y",  HEIGHT + 20)
        .style("text-anchor", "middle")
        .text("Time");
    
    //Create Y label for speed chart
    speedVis.append("svg:text")
        .attr("transform", "rotate(-90)")
        .attr("y", 10)
        .attr("x", 0 - (HEIGHT/2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("Speed"); 
        
		var speedLineGen = d3.svg.line()
							   .x(function(d) {
								   var ts = new Date(d.TimeStamp.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var startTime= new Date(d.TimeStampStart.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var endTime = new Date(d.TimeStampEnd.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var startTimeOutlier= new Date(selectedOutlier.TimeStampStart.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var endTimeOutlier = new Date(selectedOutlier.TimeStampEnd.substring(0, 19).replace(" ", "T")+ "+0000");
                                   //return xScale(d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 15:36:03"))
                                   var diff= (endTime-startTime)/(endTimeOutlier-startTimeOutlier);
                                   normval = (ts - startTime)/(endTime-startTime)
                                   return xScale(normval*diff);
							   })
							   .y(function(d) {
              		return yScale(d.Speed);
							   })
							   .interpolate("basis");
                  



    //Temporal Chart
    var vis = d3.select("#visualization"),
            WIDTH = 1000,
            HEIGHT = 300,
            MARGINS = {
                top: 20,
                right: 20,
                bottom: 20,
                left: 80
            },
			xScale = d3.scale.linear().range([MARGINS.left, WIDTH - MARGINS.right]).domain([0.0, 1.0]),
			//xScale = d3.time.scale().range([MARGINS.left, WIDTH - MARGINS.right]),
            yScale = d3.scale.linear().range([HEIGHT - MARGINS.top, MARGINS.bottom]).domain([-0.0, 0.4]),
            xAxis = d3.svg.axis()
					  .scale(xScale),
                      //.tickFormat(d3.time.format("%H:%m")),
			yAxis = d3.svg.axis()
					  .scale(yScale)
					  .orient("left");
    
		vis.append("svg:g")
		   .attr("class","axis")
		   .attr("transform", "translate(0," + (HEIGHT - MARGINS.bottom) + ")")
		   .call(xAxis);
		vis.append("svg:g")
		   .attr("class","axis")
           .attr("transform", "translate(" + (MARGINS.left) + ", " + (0) + ")")
           .call(yAxis);
    
		//Create X axis label   
		vis.append("svg:text")
		.attr("x", WIDTH / 2 )
        .attr("y",  HEIGHT+20 )
        .style("text-anchor", "middle")
        .text("Time");
    
        //Create Y axis label
        vis.append("svg:text")
        .attr("transform", "rotate(-90)")
        .attr("y", 10)
        .attr("x",0 - (HEIGHT / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("Distance"); 

        var lineGenOutlier = d3.svg.line()
							   .x(function(d) {
								   var ts = new Date(d.TimeStamp.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var startTime= new Date(selectedOutlier.TimeStampStart.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var endTime = new Date(selectedOutlier.TimeStampEnd.substring(0, 19).replace(" ", "T")+ "+0000");
                                   return xScale((ts - startTime)/(endTime-startTime));
							   })
							   .y(function(d) {
									return yScale(Math.abs(+d.LatitudePonto - selectedOutlier.LatStart ) + Math.abs(+d.LongitudePonto - selectedOutlier.LongStart ));
							   })
							   .interpolate("basis");
        
		var lineGen = d3.svg.line()
							   .x(function(d) {
								   var ts = new Date(d.TimeStamp.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var startTime= new Date(d.TimeStampStart.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var endTime = new Date(d.TimeStampEnd.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var startTimeOutlier= new Date(selectedOutlier.TimeStampStart.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var endTimeOutlier = new Date(selectedOutlier.TimeStampEnd.substring(0, 19).replace(" ", "T")+ "+0000");
                                   //return xScale(d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 15:36:03"))
                                   
                                   var diff= (endTime-startTime)/(endTimeOutlier-startTimeOutlier);
                                   if(endTime-startTime == 0) {
                                     return xScale(diff*((ts - startTime)/0.01));
                                   }

                                   normval = (ts - startTime)/(endTime-startTime);                                   
                                   return xScale(normval*diff);
							   })
							   .y(function(d) {
									return yScale(Math.abs(+d.LatitudePonto - selectedOutlier.LatStart ) + Math.abs(+d.LongitudePonto - selectedOutlier.LongStart ));
							   })
							   .interpolate("basis");

	    //MOD THIS
        //xScale.domain(d3.extent(data, function(d) { return d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 15:36:03"); }));
        //xScale.domain([d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 09:36:03"),d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 11:36:03")]);
    
		$("#hideDayBarChart").click(function() {
			if ($("#dayChart").is(':visible'))
			{
                $('#timedatediv').hide();
                //$('#multiInlinePicker').hide();
				//$("#dayChart").hide();
                //$("#timefilter").hide();
				$("#hideDayBarChart").html(">");
			}
			else
			{
                $('#timedatediv').show();
                //$('#multiInlinePicker').show();
				//$("#dayChart").show();
                //$("#timefilter").show();
				$("#hideDayBarChart").html("<");
			}
		});
	
		function parseDate(datestr) {
			return Date.parse(datestr.substring(0, 19).replace(" ", "T"));
		}


		// Create the Google Map
        var stylez = [
            {
              featureType: "all",
              elementType: "all",
              stylers: [
                { saturation: -100 }, // <-- THIS SETS TO GRAYSCALE
				{ visibility: "off" }
              ]
            },
			{
				featureType: "road",
				stylers: [
					{ visibility: "on" }
				]
			}
        ];

        var mapOptions = {
            zoom: 9,
            center: new google.maps.LatLng(RIO_CENTER_LAT, RIO_CENTER_LONG),
            mapTypeControlOptions: {
                 mapTypeIds: [google.maps.MapTypeId.ROADMAP, 'tehgrayz']
            },
        };

        map = new google.maps.Map(d3.select("#map").node(), mapOptions);
        var mapType = new google.maps.StyledMapType(stylez, { name:"Grayscale" });    
        map.mapTypes.set('tehgrayz', mapType);
        map.setMapTypeId('tehgrayz');
    
		// Load the raw data. When the data comes back, create an overlay.		
		overlay_raw.onAdd = function() {
			raw_data_layer = d3.select(this.getPanes().overlayMouseTarget).append("div")
																		  .attr("class", "rawpt");
			// Draw each marker as a separate SVG element.
			// We could use a single SVG, but what size would it have?
		};
		
		var raw_markers = [];
		overlay_raw.draw = function() {
			var projection = this.getProjection(),
			padding = 10;

			var marker = raw_data_layer.selectAll("svg")
							  .data(d3.entries(raw_data))
							  .each(transform) // update existing markers
							  .enter().append("svg:svg")
							  .each(transform)
							  .attr("class", "marker");

			// Add a circle.
			raw_markers.push(marker.append("svg:circle"));
			raw_markers[raw_markers.length - 1]
				  .attr("r", 3.0)
				  .attr("cx", padding)
				  .attr("cy", padding);
			
			function transform(d) {
				d2 = new google.maps.LatLng(+d.value[9], +d.value[10]);
				//d2 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
				d2 = projection.fromLatLngToDivPixel(d2);
				return d3.select(this)
						 .style("left", (d2.x - padding) + "px")
						 .style("top", (d2.y - padding) + "px");
			}
		};
		overlay_raw.onRemove = function() {
			$(".rawpt").remove();
			raw_markers = [];
		};
        
		function loadPtsRaw(plotTemporalChart, redrawPoints, reloadIndividualBuses) {
			if (redrawPoints)
			{
				overlay_raw.setMap(null);
				raw_data = null;
				raw_data_load_callback_count = selectedLines.length;
			}
			
			for (i=0; i < selectedLines.length; i++) {
				d3.text("data_separated_by_line_and_day/"+selectedLines[i]+"/" + dateFile, function(text) {
					raw_data = d3.csv.parseRows(text);
					raw_data.shift();
					//do sampling
					var samplingRate = Math.floor(raw_data.length/maxPts);
					if (samplingRate < 1) {
						samplingRate = 1;
					}
					raw_data = raw_data.filter(function(row,index) { 
						if (index % samplingRate != 0) {
							return false;
						}
						return true;
					});
					
					//filter by start date
					raw_data = raw_data.filter(function(row,index) {
						var ts = new Date(row[11].substring(0, 19).replace(" ", "T")+ "+0000");
						
						if (startHour > +ts.getUTCHours()) {
							return false;
						}
						else if (startHour == +ts.getUTCHours()) {
						   if (startMinute > +ts.getUTCMinutes()) {
							   return false;
						   }
						}
						
						if (endHour < +ts.getUTCHours()) {
							return false;
						}
						else if (endHour == +ts.getUTCHours()) {
						   if (endMinute < +ts.getUTCMinutes()) {
							   return false;
						   }
						}
						
						return true;
					});   
					var listOfBuses = []
					
					raw_data.filter(function(row,index) {	
						if (listOfBuses.indexOf(row[3]) == -1)
							listOfBuses.push(row[3]);
					});
					
					if (reloadIndividualBuses)
					{
						var div_list = document.getElementById("busesOfLine");
						div_list.innerHTML = "";
						div_list.style.position = "relative";
						//div_list.style.top = "0%";
						//div_list.style.left = "23%";
						//div_list.style.display = "inline-block";
						
						listOfSelectedBuses = [];
						
						for (var i=0; i<listOfBuses.length; i++)
						{
							if (listOfOutlierBuses.indexOf(listOfBuses[i]) != -1)
							{
								var div = document.createElement("div");

								div_list.appendChild(div);
								
								div.innerHTML = listOfBuses[i];
								div.style.color = "white";
								//div.style.float = "left";
								div.style.border = "1px solid #000000";
								div.style.marginLeft = "1px";
								div.style.marginRight = "1px";
								div.style.textAlign = "center";
								//div.style.display = "table-column";
								div.style.opacity = 0.4;
								if (listOfOutlierBuses.indexOf(listOfBuses[i]) != -1)
								{
									div.style.background = "red";
									div.className = "busOutlierDiv";
									//listOfBuses[i] = "*****" + listOfBuses[i];
								}
								else
								{
									div.style.background = "blue";
									div.className = "busDiv";
								}							
							}
						}
						
						$(".busDiv").hover(function() {
							$(this).css("background", "green");
						});

						$(".busOutlierDiv").hover(function() {
							$(this).css("opacity", 1.0);
						});
						
						$(".busDiv").mouseout(function() {
							$(this).css("background", "blue");
						});

						$(".busOutlierDiv").mouseout(function() {
							if (!($(this).hasClass("busselected")))
								$(this).css("opacity", 0.4);
						});
						
						$(".busOutlierDiv").click(function() {
							listOfSelectedBuses = [$(this).html()];

							$(".marker2").remove(); //remove paths between outliers

							d3.select(".busselected").style({opacity: 0.4});
							d3.select(".busselected").classed("busselected", false);
							d3.select(this).classed("busselected", true);
							d3.select(this).style({opacity: 1.0});
							
							var line = $(this).html();

							for (var j=0; j<raw_markers.length; j++)
								raw_markers[j].each(transform);
							for (var i=0; i<outlier_markers.length; i++)
								outlier_markers[i].each(transform2);
							function transform(d) {
								if (listOfSelectedBuses.indexOf(d.value[3]) != -1)
								{
									//console.log("a");
									return d3.select(this).style("opacity", 1.0);
								}
								else
								{
									//console.log("b");
									return d3.select(this).style("opacity", 0.0);
								}
							}
							function transform2(d) {
								if (d.value['BusId'] == line)
								{
									vis.selectAll("path.line").remove();
									loadPtsOutliers(true, d.value['BusId'], false);
									loadPtsRaw(true, false, false);

									$("#outlierinfo").html("<b>Selected outlier:</b><br>"+
										"<b>Start:</b> " + d.value['TimeStampStart'] + "<br>"+
										"<b>End:</b>   " + d.value['TimeStampEnd'] + "<br>"+
										"<b>Line:</b> " + d.value['Line'] + "<br>"+
										"<b>Bus Id:</b> " + d.value['BusId']
									);
								}
								if (listOfSelectedBuses.indexOf(d.value["BusId"]) != -1)
								{
									//console.log("a");
									//return d3.select(this).style("opacity", 1.0);
									return d3.select(this).style("visibility", "visible");
								}
								else
								{
									//console.log("b");
									//return d3.select(this).style("opacity", 0.0);
									return d3.select(this).style("visibility", "hidden");
								}
							}
						});
					}

          
					//select buses for temporal chart comparison. Select buses that are close to the start point of the outlier
					
          if (selectedOutlier != null)
					{
                        //select buses based on start latlong
					  selectedBuses = {}
						for (idx in raw_data){
							var dist = Math.pow(Math.pow(+raw_data[idx][9] - selectedOutlier.LatStart,2) + Math.pow(+raw_data[idx][10] - selectedOutlier.LongStart, 2),0.5);
              if (dist < MAX_DIST){                
								selectedBuses[raw_data[idx][3]] = raw_data[idx][11]; //put start timestamp here 
							}
						}
                        //select buses based on end latlong
                        selectedBuses2 = {}
                        for (idx in raw_data){
                            if (raw_data[idx][3] in selectedBuses) {
							   var dist = Math.pow(Math.pow(+raw_data[idx][9] - selectedOutlier.LatEnd,2) + Math.pow(+raw_data[idx][10] - selectedOutlier.LongEnd, 2), 0.5);
							    if (dist < MAX_DIST){
                                    //only select as an end timestamp if it larger than start timestamp
                                    var startTime = new Date(selectedBuses[raw_data[idx][3]].substring(0, 19).replace(" ", "T") + "+0000");
						            var ts = new Date(raw_data[idx][11].substring(0, 19).replace(" ", "T") + "+0000");
                                    if(+startTime.getUTCHours() > +ts.getUTCHours()) {
                                        continue;
                                    }
                                    else if (+startTime.getUTCHours() == +ts.getUTCHours()) {
                                        if (+startTime.getUTCMinutes() > +ts.getUTCMinutes()) {
                                            continue;
                                        }
                                    }
                                    if (!(raw_data[idx][3] in selectedBuses2)){
							            selectedBuses2[raw_data[idx][3]] = [selectedBuses[raw_data[idx][3]], raw_data[idx][11]]; //put end timestamp along with start timestamp 
                                    }
							    }
                            }
						}
            //filter by start date and end date of the bus
						data2 = {}; 
						for (idx in raw_data) {
							if (min_latitude_bounding == null || min_latitude_bounding > raw_data[idx][9])
								min_latitude_bounding = raw_data[idx][9];
							if (max_latitude_bounding == null || max_latitude_bounding < raw_data[idx][9])
								max_latitude_bounding = raw_data[idx][9];
							if (min_longitude_bounding == null || min_longitude_bounding > raw_data[idx][10])
								min_longitude_bounding = raw_data[idx][10];
							if (max_longitude_bounding == null || max_longitude_bounding < raw_data[idx][10])
								max_longitude_bounding = raw_data[idx][10];
								
							if (!(raw_data[idx][3] in selectedBuses2)) {
								continue;
							}
                            var startTime = new Date(selectedBuses2[raw_data[idx][3]][0].substring(0, 19).replace(" ", "T") + "+0000");
						    var endTime = new Date(selectedBuses2[raw_data[idx][3]][1].substring(0, 19).replace(" ", "T") + "+0000");
							var ts = new Date(raw_data[idx][11].substring(0, 19).replace(" ", "T") + "+0000");
						  
							if(+startTime.getUTCHours() > +ts.getUTCHours()) {
								continue;
							}
							else if (+startTime.getUTCHours() == +ts.getUTCHours()) {
								if (+startTime.getUTCMinutes() > +ts.getUTCMinutes()) {
									continue;
								}
							}
							
							if(+endTime.getUTCHours() < +ts.getUTCHours()) {
								continue;
							}
							else if (+endTime.getUTCHours() == +ts.getUTCHours()) {
								if (+endTime.getUTCMinutes() < +ts.getUTCMinutes()) {
									continue;
								}
							}
							if (!(raw_data[idx][3] in data2)) {
								data2[raw_data[idx][3]] = []
							}
                            item = {TimeStamp: raw_data[idx][11],
                                    TimeStampStart: selectedBuses2[raw_data[idx][3]][0],
                                    TimeStampEnd: selectedBuses2[raw_data[idx][3]][1],
                                    LatitudePonto: raw_data[idx][9],
                                    LongitudePonto: raw_data[idx][10],
                                    Speed: raw_data[idx][13]
                                   }
                            
							data2[raw_data[idx][3]].push(item);
						}
					}

          if(plotTemporalChart) {
					  //add to the temporal chart
            
				  	for (var key in data2) {
              
					  	vis.append('svg:path')
						   .attr('d', lineGen(data2[key]))
						   .attr('stroke', 'blue')
						   .attr('stroke-width', 1)
						   .attr("class", "line")
						   .attr('fill', 'none');
					  }
          }
          
                     //add to the speed chart
					for (var key in data2) {
						speedVis.append('svg:path')
						   .attr('d', speedLineGen(data2[key]))
						   .attr('stroke', 'blue')
						   .attr('stroke-width', 1)
						   .attr("class", "line")
						   .attr('fill', 'none');
					}
          
					if (redrawPoints)
						raw_data_load_callback();
					//var overlay_raw = new google.maps.OverlayView();
					// Add the container when the overlay is added to the map.
					// Bind our overlay to the map…
				});
			}
			//overlay_raw.draw();
		}
		//var rectangle;
		var bounds = new google.maps.LatLngBounds();
		function raw_data_load_callback() {
			raw_data_load_callback_count = raw_data_load_callback_count - 1;
			if (raw_data_load_callback_count == 0)
				overlay_raw.setMap(map);
			
			bounds = new google.maps.LatLngBounds();
			bounds.extend(new google.maps.LatLng(+max_latitude_bounding, +max_longitude_bounding));
			bounds.extend(new google.maps.LatLng(+min_latitude_bounding, +min_longitude_bounding));
			map.setCenter(new google.maps.LatLng((+min_latitude_bounding + +max_latitude_bounding)/2, (+min_longitude_bounding + +max_longitude_bounding)/2));
			map.fitBounds(bounds);
			/*if (rectangle != null)
				rectangle.setMap(null);
			rectangle = new google.maps.Rectangle({
				strokeColor: '#FF0000',
				strokeOpacity: 0.8,
				strokeWeight: 2,
				fillColor: '#FF0000',
				fillOpacity: 0.35,
				map: map,
				bounds: new google.maps.LatLngBounds(
					new google.maps.LatLng(max_latitude_bounding, max_longitude_bounding),
					new google.maps.LatLng(min_latitude_bounding, min_longitude_bounding))
			});*/
		}
		
		overlay_outliers.onAdd = function() {
			//remove all previous layers.
			myNode = this.getPanes().overlayMouseTarget;
			while (myNode.firstChild) {
				myNode.removeChild(myNode.firstChild);
			}

			outlier_data_layer = d3.select(this.getPanes().overlayMouseTarget).append("div")
																 .attr("class", "outliers");
		};
		
		var outlier_markers = [];

		overlay_outliers.draw = function() {
			var projection = this.getProjection(),
			padding = 10;
			
			var tooltip = d3.select("body")
							.append("div")
							.style("position", "absolute")
							.style("z-index", "10")
							.style("visibility", "hidden");
							//.text("a simple tooltip");
            
            var marker = outlier_data_layer.selectAll("svg")
										   .data(d3.entries(outlier_data))
										   .each(
											  function (d) {
												d = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
												d = projection.fromLatLngToDivPixel(d);
												return d3.select(this)
												  .style("left", (d.x - padding) + "px")
												  .style("top", (d.y - padding) + "px");
											  }
										   )
										  .style("width", "14px")
										  .style("height", "14px")
										   .enter().append("svg:svg")
										   .each(
											  function (d) {
												d = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
												d = projection.fromLatLngToDivPixel(d);
												return d3.select(this)
												  .style("left", (d.x - padding) + "px")
												  .style("top", (d.y - padding) + "px");
											  }
										   )
										   .style("width", "14px")
										   .style("height", "14px")
                                           .style("z-index", 20)
										   .attr("class", "marker")
										   .on("click", function(d, i) {
												vis.selectAll("path.line").remove();
												loadPtsOutliers(true, d.value['BusId'], false);
												loadPtsRaw(true, false, false);
                                                $("#outlierinfo").html("<b>Selected outlier:</b><br>"+
													"<b>Start:</b> " + d.value['TimeStampStart'] + "<br>"+
													"<b>End:</b>   " + d.value['TimeStampEnd'] + "<br>"+
													"<b>Line:</b> " + d.value['Line'] + "<br>"+
													"<b>Bus Id:</b> " + d.value['BusId']);
													
												});
			//console.log(marker);
			// Add a circle.
			outlier_markers.push(marker.append("svg:circle"));
			outlier_markers[outlier_markers.length - 1]
				  //.attr("r", function(d) { return (3.0 + 5.0 * d.value['TimeStampPercentage']) })
				  .attr("r", 4.0)
				  .attr("cx", padding)
				  .attr("cy", padding);
				  /*.on("click", function(d, i) {
					  tooltip.style("visibility", "visible");
            //when clicking on an outlier, it will be plotted on the temporal chart
            
            //remove all existing lines in the temporal chart
			      vis.selectAll("path.line").remove();
            loadPtsOutliers(true, d.value['BusId']);
            loadPtsRaw(true);
     
                      alert("Selected node:\n" +
                            "Start: " + d.value['TimeStampStart'] + "\n"+
                            "End:   " + d.value['TimeStampEnd'] + "\n"+
                            "Line: " + d.value['Line'] + "\n"+
                            "Bus Id: " + d.value['BusId']);		  
				  });*/
            
			//Add a label.
			/*marker.append("svg:text")
				  .attr("x", padding + 7)
				  .attr("y", padding)
				  .attr("dy", ".31em")
				  .text(function(d) { 
							//if (selectedLines[0] =="All") {
							//	return d.value['Line'];
							//}
							//else{
						    //return d.value['row'];
                            //}
								return "";
						});*/
            $(".marker2").remove();
			//if (selectedLines.length != 0 && $('#ConnectedPts').is(':checked')) {
            if (selectedLines.length != 0) {
                //remove all lines
                
                var marker = outlier_data_layer.selectAll("svg2")
                                               .data(d3.entries(outlier_data))
                                               .style("z-index", 1)
                                               .each(
                                                  function (d) {
                                                    d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                    d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     var minx = Math.min(d1.x, d2.x);
                                                     var miny = Math.min(d1.y, d2.y);
                                                    return d3.select(this)
                                                      .style("left", (minx) + "px")
                                                      .style("top", (miny) + "px");
                                                  }
                                               )
                                               .enter().append("svg:svg")
                                               .each(
                                                  function (d) {
                                                    d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                    d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     var minx = Math.min(d1.x, d2.x);
                                                     var miny = Math.min(d1.y, d2.y);
                                                    return d3.select(this)
                                                      .style("left", (minx) + "px")
                                                      .style("top", (miny) + "px");
                                                  }
                                               )
                                               .attr("class", "marker2");
                marker.append("svg:line")
                      .attr("class", "connectionline")
                      .attr("x1", 0)
                      .attr("y1", function (d) {     d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                     d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     if (d1.x>d2.x){
                                                         return d2.y - Math.min(d1.y,d2.y);
                                                     }else{
                                                         return d1.y - Math.min(d1.y,d2.y);
                                                     }
                                                  })
                      .attr("x2", function (d) {     d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                     d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     var minx = Math.min(d1.x, d2.x);
                                                     var maxx = Math.max(d1.x, d2.x);
                                                     return maxx-minx;
                                                  })
                      .attr("y2", function (d) {     d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                     d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     if (d1.x>d2.x){
                                                         return d1.y - Math.min(d1.y,d2.y);
                                                     }else{
                                                         return d2.y - Math.min(d1.y,d2.y);
                                                     }
                                                  });
            }
		};
    
		overlay_outliers.onRemove = function() {
			$(".outliers").remove();
			outlier_markers = [];
		};

		var daysBars = [];
		function loadOutliersPerDay() {
			var barchart_data = [];
			d3.csv(outliersperdayfile, function(data) {
				data.forEach(function(d) {
					barchart_data.push({key: d.Date, number_of_outliers: d.NumberOfOutliers});
				});

				var barWidth = 40;
				var height = 179;

				var y = d3.scale.linear()
					.domain([0, d3.max(barchart_data, function(d) { return Math.log(d.number_of_outliers)*1.05; })])
					.range([0, height]);

				var chart = d3.select(".verticalBarchart")
								.attr("width", barWidth * barchart_data.length)
								.attr("height", height);

				var bar = chart.selectAll("g")
								.data(barchart_data)
								.enter().append("g")
								.attr("transform", function(d, i) { return "translate(" + i * barWidth + "," + (height - y(Math.log(d.number_of_outliers))) + ")"; });
                               
				daysBars.push(bar.append("rect")
					.attr("height",  function(d) { return y(d.number_of_outliers); })
					.attr("width", barWidth - 1)
					.on("click", function(d, i) {
									d3.select(".vselected").style({fill: "steelblue"});
									d3.select(".vselected").classed("vselected", false);
									d3.select(this).classed("vselected", true);
									d3.select(this).style({fill: 'red'});
                  fields = d.key.split("/");
									dateFile = fields[1] + "-" + fields[0] + "-2013";
                  outliersfile = "outliers/" + fields[1] + "_" + fields[0] + ".csv";
									loadLstboxFromOutliers();
                   
								 })
					.on("mouseover", function(d, i) {
										d3.select(this).style({opacity: '0.6'});
										})
					.on("mouseout", function(d, i) {
										d3.select(this).style({opacity: '1.0'});
									 }));

				bar.append("text")
					.attr("x", barWidth / 2)
					.attr("y", function (d) { y(Math.log(d.number_of_outliers)); })
					.attr("dx", "1em")
					.attr("transform", function(d) { return "translate(0, " + (y(Math.log(d.number_of_outliers)) - 3) + ")"; })
					.text(function(d) { return d.key; })
					.on("click", function(d, i) {
									fields = d.key.split("/");
									dateFile = fields[1] + "-" + fields[0] +  "-2013";
									outliersfile = "outliers/" + fields[1] + "_" + fields[0] + ".csv";
									loadLstboxFromOutliers();
								 });
				
				bar.append("text")
					.attr("x", barWidth / 2)
					.attr("y", function (d) { y(d.number_of_outliers); })
					.attr("dx", ".8em")
					//.attr("transform", function(d) { return "translate(0, " + 12 + ")"; })
					.text(function(d) { return d.number_of_outliers; })
					.on("click", function(d, i) {
									fields = d.key.split("/");
									dateFile = fields[1] + "-" + fields[0] + "-2013";
									outliersfile = "outliers/" + fields[1] + "_" + fields[0] + ".csv";
									loadLstboxFromOutliers();
								 });
				colorDefaultDay();
			});
		}
		
		function colorDefaultDay()
		{
			for (var i=0; i<daysBars.length; i++)
				daysBars[i].each(transform);

			function transform(d)
			{
				if (d.key == "12/5")
				{
					d3.select(this).classed("vselected", true);
					d3.select(this).style({fill: 'red'});
				}
			}
		}
			
		function loadPtsOutliers(plotTemporalChart, busID, redrawPoints) {
            
            //erase selected oulier div
            $("#outlierinfo").html("<br><br><b>No Outlier Selected<b>");
            
			if (redrawPoints)
			{
				overlay_outliers.setMap(null);
				outlier_data = null;
				
				min_latitude_bounding = null;
				max_latitude_bounding = null;
				min_longitude_bounding = null;
				max_longitude_bounding = null;
			}

			d3.csv(outliersfile, function(data) {
				data = data.filter(function(row,index) {
					var contains = false;
					if (selectedLines.length == 0)
						contains = true;
					for (i in selectedLines) {
            if(row['Linha'] == selectedLines[i]) {
              contains = true;
            }
					}
					
					return contains;
				});
				outlier_data = [];
				var lines_outliers = {};  
				k = 0;
                
				//pts must be structured as rows
				for (row in data) {
					var minreftime = parseDate(data[row]['TimeStamp_19']); 
					var maxreftime = parseDate(data[row]['TimeStamp_0']); 
                    //console.log("starttime: " + data[row]['TimeStamp_19']);
                    //console.log("endtime: " + data[row]['TimeStamp_0']);
                    
					for (i = 19; i>=0; i--){
						var timestamp = parseDate(data[row]['TimeStamp_' + i]);
                      
                        if (i>=1){
                            var TimeStampPrevious = data[row]['TimeStamp_'+(i-1)];
                            var LatPrevious = data[row]['LatitudePonto_'+(i-1)];
                            var LongPrevious = data[row]['LongitudePonto_'+(i-1)];
                        }else{
                            var TimeStampPrevious = data[row]['TimeStamp_'+i];
                            var LatPrevious = data[row]['LatitudePonto_'+i];
                            var LongPrevious = data[row]['LongitudePonto_'+i];
                        }
						outlier_data[k] = {
							TimeStampPercentage: (timestamp - minreftime) / (maxreftime-minreftime), 
							TimeStampStart:data[row]['TimeStamp_19'].substring(0, 19),
							TimeStampEnd:data[row]['TimeStamp_0'].substring(0, 19),
							TimeStamp:data[row]['TimeStamp_'+i],
							LatitudePonto:data[row]['LatitudePonto_'+i],
                            LatStart:data[row]['LatitudePonto_19'],
                            LongStart:data[row]['LongitudePonto_19'],
                            LatEnd:data[row]['LatitudePonto_0'],
                            LongEnd:data[row]['LongitudePonto_0'],
							LongitudePonto:data[row]['LongitudePonto_'+i],
                             TimeStampPrevious: TimeStampPrevious,
							LatitudePontoPrevious:LatPrevious,
							LongitudePontoPrevious:LongPrevious,
              Speed:data[row]['Speed_'+i],
							row:row,
							BusId:data[row]["Onibus"],
							Line:data[row]["Linha"]
						};
						if (min_latitude_bounding == null || min_latitude_bounding > outlier_data[k]['LatitudePonto'])
							min_latitude_bounding = outlier_data[k]['LatitudePonto'];
						if (max_latitude_bounding == null || max_latitude_bounding < outlier_data[k]['LatitudePonto'])
							max_latitude_bounding = outlier_data[k]['LatitudePonto'];
						if (min_longitude_bounding == null || min_longitude_bounding > outlier_data[k]['LongitudePonto'])
							min_longitude_bounding = outlier_data[k]['LongitudePonto'];
						if (max_longitude_bounding == null || max_longitude_bounding < outlier_data[k]['LongitudePonto'])
							max_longitude_bounding = outlier_data[k]['LongitudePonto'];
						k = k + 1;
					} 
				}
		   
				//do sampling
				var samplingRate = Math.floor(outlier_data.length/maxPts);

				if (samplingRate < 1){
					samplingRate = 1;
				}
				outlier_data = outlier_data.filter(function(row,index) { 
					if (index % samplingRate != 0) {
						return false;
					}
					return true;
				}); 
			
				//filter by start date
				outlier_data = outlier_data.filter(function(row,index) {
					var ts = new Date(row["TimeStamp"].substring(0, 19).replace(" ", "T")+ "+0000");
					if (startHour > +ts.getUTCHours()) {
						return false;
					}
					else if (startHour == +ts.getUTCHours()) {
						if (startMinute > +ts.getUTCMinutes()) {
							return false;
						}
					}
					
					if(endHour < +ts.getUTCHours()) {
						return false;
					}
					else if (endHour == +ts.getUTCHours()) {
					   if (endMinute< +ts.getUTCMinutes()) {
						   return false;
					   }
					}
					return true;
				});
				
				listOfOutlierBuses = []
					
				outlier_data.filter(function(row,index) {
					//console.log(row);
					if (listOfOutlierBuses.indexOf(row["BusId"]) == -1)
						listOfOutlierBuses.push(row["BusId"]);
				});
				
                if(busID == "") {
                  //set the selected outlier var with the first point of the first outlier. Its timestamp and coordinates will be used so select raw points in the temporal chart
                  selectedOutlier = outlier_data[0];
                } else{
                  for(row in outlier_data) {
                    if (outlier_data[row]["BusId"] == busID){
                      selectedOutlier = outlier_data[row];
                      break;
                    }
                  }
                }
                 
                //remove duplicated outliers
                var startTimeAbs = new Date(selectedOutlier.TimeStampStart.substring(0, 19).replace(" ", "T")+ "+0000");
                var endTimeAbs = new Date(selectedOutlier.TimeStampEnd.substring(0, 19).replace(" ", "T")+ "+0000");
                var startTime = new Date(2000, 0, 0, startTimeAbs.getHours(), startTimeAbs.getMinutes(), 0, 0);
                var endTime = new Date(2000, 0, 0, endTimeAbs.getHours(), endTimeAbs.getMinutes(), 0, 0);
                outlier_data_by_bus = {};
                outlier_data_by_bus2 = {};
                
                for (row in outlier_data) {
                    if (outlier_data[row]["BusId"] == selectedOutlier["BusId"]){
                        if (!((outlier_data[row]["BusId"]+outlier_data[row]["TimeStamp"]) in outlier_data_by_bus)){
                              outlier_data_by_bus[outlier_data[row]["BusId"]+outlier_data[row]["TimeStamp"]] = 1;
                              if (!(outlier_data[row]["BusId"] in outlier_data_by_bus2)){
                                  outlier_data_by_bus2[outlier_data[row]["BusId"]] = [];
                              }
                              outlier_data_by_bus2[outlier_data[row]["BusId"]].push(outlier_data[row]);

                              //update start and end dates of the selected outlier    
                              var tsAbs = new Date(outlier_data[row]["TimeStamp"].substring(0, 19).replace(" ", "T")+ "+0000");
                              var ts = new Date(2000, 0, 0, tsAbs.getHours(), tsAbs.getMinutes(), 0, 0);
                          
                              if (ts <= startTime){
                                  startTime = ts;
                                  selectedOutlier.TimeStampStart = outlier_data[row]["TimeStamp"];
                                  selectedOutlier.LatStart = outlier_data[row]["LatitudePonto"];
                                  selectedOutlier.LongStart = outlier_data[row]["LongitudePonto"];
                              }
                              if (ts >= endTime){
                                  endTime = ts;
                                  selectedOutlier.TimeStampEnd = outlier_data[row]["TimeStamp"];
                                  selectedOutlier.LatEnd = outlier_data[row]["LatitudePonto"];
                                  selectedOutlier.LongEnd = outlier_data[row]["LongitudePonto"];
                              }
                        }
                    }    
				        }
        
              if(plotTemporalChart) {
          		  //add to the temporal chart
                for (key in outlier_data_by_bus2){
                    vis.append('svg:path')
                      .attr('d', lineGenOutlier(outlier_data_by_bus2[key]))
                      .attr('stroke', 'red')
                      .attr('stroke-width', 3)
                      .attr("class", "line")
                      .attr('fill', 'none');
                }
              }
               //add to the speed chart
               /* for (key in outlier_data_by_bus2){
                    speedVis.append('svg:path')
                      .attr('d', speedLineGen(outlier_data_by_bus2[key]))
                      .attr('stroke', 'red')
                      .attr('stroke-width', 3)
                      .attr("class", "line")
                      .attr('fill', 'none');
                }*/
                
				if (redrawPoints)
				{
					overlay_outliers.setMap(map);
					loadPtsRaw(false, true, true);
				}
			});
		}
		
		function sortByNumberOfOutliers(a, b) 
		{
			if (a.number_of_outliers < b.number_of_outliers)
				return 1;
			if (a.number_of_outliers > b.number_of_outliers)
				return -1;
			
			return 0;
		}
		
		function sortByLabel(a, b)
		{
			var temp_a = Number(a.key);
			var temp_b = Number(b.key);
			
			if (temp_a < temp_b)
				return -1;
			if (temp_a > temp_b)
				return 1;
			
			return 0;
		}
	
		function changeSortLineBarChart()
		{
            
			if (sortLineBarChartByNumberOfOutliers){
				sortLineBarChartByNumberOfOutliers = false;
                $("#btnSort").html('Sort by number of outliers');
            }else{
				sortLineBarChartByNumberOfOutliers = true;
                $("#btnSort").html('Sort by line name');
            }
			loadLstboxFromOutliers();
		}
	
		function loadLstboxFromOutliers() {
            //first, remove all existing bars in the bar chart
            d3.select(".barchart").selectAll("g").remove();
            
            //select all outliers for the selected day
            //selectedLines = ["All"];
			selectedLines = [];
            loadPts();
            
			d3.csv(outliersfile, function(data) {
				var data2 = [];
				var lines_outliers = {};
				var lines_outliers_total = {};
				for (row in data){
					if (!(+data[row]['Linha'] in lines_outliers)) {
						lines_outliers[data[row]['Linha']] = {};
					}                                                                                                                                                                                                

                    lines_outliers[+data[row]['Linha']][data[row]['Onibus']] = 1; //add bus
					lines_outliers_total[(+data[row]['Linha']) + "_" + data[row]['Onibus']] = 1;
				}
				
				var barchart_data = [];
				var max = 0;
                //first remove previous bars
            
                for (line in lines_outliers)
				{
        	        barchart_data.push({key: line, number_of_outliers: Object.keys(lines_outliers[line]).length});
					if (Object.keys(lines_outliers[line]).length > max)
						max = Object.keys(lines_outliers[line]).length;
				}
				
				if (sortLineBarChartByNumberOfOutliers)
					barchart_data.sort(sortByNumberOfOutliers);
				else
					barchart_data.sort(sortByLabel);
                
				//add "All"
				var width = 280,//420
					barHeight = 20;

				var x = d3.scale.linear()
					.domain([0, d3.max(barchart_data, function(d) { return d.number_of_outliers; })])
					.range([0, width]);
           
				var chart = d3.select(".barchart")
					.attr("width", width)
					.attr("height", barHeight * barchart_data.length);
                
				var bar = chart.selectAll("g")
					.data(barchart_data)
				    .enter().append("g")
					.attr("transform", function(d, i) { return "translate(0," + i * barHeight + ")"; });

				bar.append("rect")
					.attr("width",  function(d) { return Math.max(45, x(d.number_of_outliers)); })
					.attr("height", barHeight - 1)
					.on("click", function(d, i) {
									d3.select(".selected").style({fill: "steelblue"});
									d3.select(".selected").classed("selected", false);

									d3.select(this).classed("selected", true);
									d3.select(this).style({fill: 'red'});
									selectedLines = [d.key];
									loadPts();
								 })
					.on("mouseover", function(d, i) {
										d3.select(this).style({opacity: '0.6'});
										})
					.on("mouseout", function(d, i) {
										d3.select(this).style({opacity: '1.0'});
									 });

				bar.append("text")
					.attr("x", function(d) { return (d.key).length * 5.5 + 2; })
					.attr("y", barHeight / 2)
					.attr("dy", ".35em")
					.text(function(d) { return d.key; })
					.on("click", function(d, i) {
									selectedLines = [d.key];
									loadPts();
								 });

				bar.append("text")
					.attr("x", function(d) { return Math.max(42, x(d.number_of_outliers) - 3); })
					.attr("y", barHeight / 2)
					.attr("dy", ".35em")
					.text(function(d) { return d.number_of_outliers; })
					.on("click", function(d, i) {
									selectedLines = [d.key];
									loadPts();
								 });									
			});
		}
		function format2digits(n){
            return n > 9 ? "" + n: "0" + n;
        }
		function loadPts() {
			var lstbox = document.getElementById("lstbox_lines");
			//remove all existing lines in the temporal chart
			vis.selectAll("path.line").remove();
            $(".marker2").remove();

			/*var startTime = document.getElementById("inputStartTime").value;
			startHour = Math.floor(startTime/60);
			startMinute = (startTime%60)
			document.getElementById("valueStartTime").innerHTML = format2digits(startHour) + ":" + format2digits(startMinute);

			var timeRange = document.getElementById("inputTimeRange").value;
			rangeHour = Math.floor(timeRange/60);
			rangeMinute = (timeRange%60)
			document.getElementById("valueTimeRange").innerHTML = format2digits(rangeHour) + ":" + format2digits(rangeMinute);*/

			loadPtsOutliers(false, "", true);
			
		}
        
        //force reset of slide bars
        //document.getElementById("inputStartTime").value = 0;
        //document.getElementById("inputTimeRange").value = 1439;
        //initalize canvastime
        var canvas = initCanvas('canvastime');
        var rect1x = 10;
        var rect2x = canvas.width-10;
        var selrect = -1;
        canvas.update = function(g) {
            this.g = g; // so the drawLine method will know where to draw to.
            
			g.clearRect(0, 0, g.width, g.height);
			
            //check if clicked on rectangle 1 or 2
            if (this.cursor.x > rect1x-10 && this.cursor.x < rect1x+10  && this.cursor.z==1){
                selrect = 1;
            }
            else if (this.cursor.x > rect2x-10 && this.cursor.x < rect2x+10  && this.cursor.z==1){
                selrect = 2;
            }
            //else if (this.cursor.x > rect1x+10 && this.cursor.x < rect2x-10  && this.cursor.z==1){
            //    selrect = 3;
            //}
            
            if ( this.cursor.z==0 ){
                selrect = -1;
            }
            
            if (selrect==1){
                rect1x = Math.max(10,this.cursor.x);
            }
            else if (selrect==2){
                rect2x = Math.min(canvas.width-10,this.cursor.x);
            }
            //else if (selrect==3){
            //    var range = rect2x-rect1x;
            //    rect1x = Math.max(10,this.cursor.x-(range/2));
            //    rect2x = Math.min(canvas.width-10,this.cursor.x+(range/2));
            //}
            
            //if the rectangles are too close, put them apart
            if (rect2x-rect1x<40){
                rect2x = Math.min(canvas.width-10,rect1x+40);
            }
            
            //draw rectangle 1 and 2
            g.fillStyle="dimgray";
            g.fillRect(rect1x-10,0,20,this.height);
            g.fillRect(rect2x-10,0,20,this.height);

            /*g.fillStyle="black";
            g.rect(rect1x-10,0,20,this.height);
            g.rect(rect2x-10,0,20,this.height);
			g.stroke();*/
            
            g.fillStyle="darkgray";
            g.fillRect(rect1x+10,0,rect2x-rect1x-20,this.height);
            
            var startTime = 1439*(rect1x-10)/this.width;
			startHour = Math.floor(startTime/60);
			startMinute = Math.floor(startTime%60);
			document.getElementById("valStartTime").innerHTML = format2digits(startHour) + ":" + format2digits(startMinute);
            
            var endTime = 1439*(rect2x+10)/this.width;
			endHour = Math.floor(endTime/60);
			endMinute = Math.floor(endTime%60);
			document.getElementById("valEndTime").innerHTML = format2digits(endHour) + ":" + format2digits(endMinute);
            
        }    
		loadOutliersPerDay();
		loadLstboxFromOutliers();
    </script>
</html>