<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
    <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script>
    <script type="text/javascript" src="d3.v2.js"></script>
    <script type="text/javascript" src="jquery.min.js"></script>
    <script src=drawlib1.js></script>
    <style type="text/css">
		html, body {
		  width: 100%;
		  height: 100%;
		  margin: 0;
		  padding: 0;
		}

		#map {
		  width: 100%;
		  height:700px;
		  margin: 0;
		  padding: 0;
		}
		.rawpt, .rawpt svg {
		  position: absolute;
		}

		.rawpt svg {
		  width: 60px;
		  height: 20px;
		  padding-right: 100px;
		  font: 10px sans-serif;
          z-index: 1;
		}

		.rawpt circle {
		  fill: blue;
		  opacity: 0.4;
		}

		.outliers, .outliers svg {
		  position: absolute;
		}

		.outliers svg {
		  width: 1000px;
		  height: 1000px;
		  padding-right: 100px;
		  font: 10px sans-serif;
          z-index: 2;
		}

		.outliers circle {
		  fill: red;
		  stroke: black;
		  stroke-width: 0.2px;
		}
		.axis path {
			fill: none;
			stroke: #777;
			shape-rendering: crispEdges;
		}
		.axis text {
			font-family: Lato;
			font-size: 13px;
		}

		.barchart rect {
			fill: steelblue;
		}

		.barchart text {
			fill: white;
			font: 10px sans-serif;
			text-anchor: end;
		}
		
		.sortLineBarChartDiv {
			position: fixed;
			left: 0px;
		}
		
		.barchartDiv {
			float: left;
			overflow-y: scroll;
			height: 680px;
			width: 300px;
		}
		
		.verticalBarchartDiv {
			overflow-x: scroll;
			height: 200px;
			width: 1263px;
		}

		.verticalBarchart rect {
			fill: steelblue;
		}

		.verticalBarchart text {
			fill: black;
			font: 10px sans-serif;
			text-anchor: end;
		}

		.axis path {
			fill: none;
			stroke: #777;
			shape-rendering: crispEdges;
		}
		.axis text {
			font-family: Lato;
			font-size: 13px;
		}

	</style>
	</head>
	<body>
        <div id="dayChart" class="verticalBarchartDiv">
            <svg class="verticalBarchart"></svg>
        </div>
        <br>
        <font id="valStartTime"></font><canvas id=canvastime width=800 height=30></canvas><font id="valEndTime"></font>
        <!--<input type="checkbox" id="ConnectedPts" value="ConnectedPtsValue" onchange="loadPts()" checked>Connected Points<br>-->
        <br><br>
        
		<div style="width: 100%; height: 700px; overflow: hidden;">
			<div id="sortLineBarChartDiv"><input type="checkbox" id="sortLineBarChart" onchange="changeSortLineBarChart()">Sort by # of Outliers</input></div>
			<div class="barchartDiv">
				<svg class="barchart"></svg>
			</div>
			<!--<div style="width: 100px; float: left;"> Lines<br>
				<select id = "lstbox_lines"
					onChange="loadPts()"
					multiple = "multiple"
					size = "30">
				  </select>
			</div>-->
			<div style="margin-left: 300px;"> <div id="map"></div> </div>
		</div>
		<div class="container">
			<div class="jumbotron">
				<svg id="visualisation" width="1000" height="350"></svg>
			</div>
		</div>
	</body>

	<script type="text/javascript">
		var maxPts = 2000;
		var outliersfile = "5_12.csv";
		var outliersperdayfile = "number_of_outliers_per_day.csv";
		var dateFile = "5-12-2013_sorted_with_speed";
		var startHour;
		var startMinute;
		var endHour;
		var endMinute;
		var selectedOutlier;
		var sortLineBarChartByNumberOfOutliers = false;
		var MAX_DIST = (0.003); //maximum distance to 2 pts be considered close. 1 degree latitude = 100km. 1 meter = 0.00001 degrees. 100 meters = 0.001
		var RIO_CENTER_LAT = -22.911773;
		var RIO_CENTER_LONG = -43.230199;
		var overlay_outliers = new google.maps.OverlayView();
		var outlier_data;
		var outlier_data_layer;
		var overlay_raw = new google.maps.OverlayView();
		var raw_data;
		var raw_data_layer;
		var raw_data_load_callback_count;
		var selectedLines;
		var min_latitude_bounding = null;
		var max_latitude_bounding = null;
		var min_longitude_bounding = null;
		var max_longitude_bounding = null;
    </script>
    
	<script type="text/javascript">
    
		var vis = d3.select("#visualisation"),
            WIDTH = 1000,
            HEIGHT = 300,
            MARGINS = {
                top: 20,
                right: 20,
                bottom: 20,
                left: 80
            },
			xScale = d3.scale.linear().range([MARGINS.left, WIDTH - MARGINS.right]).domain([0.0, 1.0]),
			//xScale = d3.time.scale().range([MARGINS.left, WIDTH - MARGINS.right]),
            yScale = d3.scale.linear().range([HEIGHT - MARGINS.top, MARGINS.bottom]).domain([-0.0, 0.4]),
            xAxis = d3.svg.axis()
					  .scale(xScale),
                      //.tickFormat(d3.time.format("%H:%m")),
			yAxis = d3.svg.axis()
					  .scale(yScale)
					  .orient("left");
    
		vis.append("svg:g")
		   .attr("class","axis")
		   .attr("transform", "translate(0," + (HEIGHT - MARGINS.bottom) + ")")
		   .call(xAxis);
		vis.append("svg:g")
		   .attr("class","axis")
           .attr("transform", "translate(" + (MARGINS.left) + ", " + (0) + ")")
           .call(yAxis);
        
		//Create X axis label   
		vis.append("svg:text")
		.attr("x", WIDTH / 2 )
        .attr("y",  HEIGHT+20 )
        .style("text-anchor", "middle")
        .text("Time");
    
        //Create Y axis label
        vis.append("svg:text")
        .attr("transform", "rotate(-90)")
        .attr("y", 10)
        .attr("x",0 - (HEIGHT / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("Distance"); 
        
		var lineGen = d3.svg.line()
							   .x(function(d) {
								   var ts = new Date(d.TimeStamp.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var startTime= new Date(d.TimeStampStart.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var endTime = new Date(d.TimeStampEnd.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var startTimeOutlier= new Date(selectedOutlier.TimeStampStart.substring(0, 19).replace(" ", "T")+ "+0000");
                                   var endTimeOutlier = new Date(selectedOutlier.TimeStampEnd.substring(0, 19).replace(" ", "T")+ "+0000");
                                   //return xScale(d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 15:36:03"))
                                   var diff= (endTime-startTime)/(endTimeOutlier-startTimeOutlier);
                                   normval = (ts - startTime)/(endTime-startTime)
                                   return xScale(normval*diff);
							   })
							   .y(function(d) {
									return yScale(Math.abs(+d.LatitudePonto - selectedOutlier.LatStart ) + Math.abs(+d.LongitudePonto - selectedOutlier.LongStart ));
							   })
							   .interpolate("basis");
        
	    //MOD THIS
        //xScale.domain(d3.extent(data, function(d) { return d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 15:36:03"); }));
        //xScale.domain([d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 09:36:03"),d3.time.format("%Y-%m-%d %H:%M:%S").parse("2013-03-12 11:36:03")]);
    
		function parseDate(datestr) {
			return Date.parse(datestr.substring(0, 19).replace(" ", "T"));
		}
		// Create the Google Map
        var stylez = [
            {
              featureType: "all",
              elementType: "all",
              stylers: [
                { saturation: -100 } // <-- THIS SETS TO GRAYSCALE
              ]
            }
        ];

        var mapOptions = {
            zoom: 9,
            center: new google.maps.LatLng(RIO_CENTER_LAT, RIO_CENTER_LONG),
            mapTypeControlOptions: {
                 mapTypeIds: [google.maps.MapTypeId.ROADMAP, 'tehgrayz']
            },
        };

        map = new google.maps.Map(d3.select("#map").node(), mapOptions);
        var mapType = new google.maps.StyledMapType(stylez, { name:"Grayscale" });    
        map.mapTypes.set('tehgrayz', mapType);
        map.setMapTypeId('tehgrayz');
    
		// Load the raw data. When the data comes back, create an overlay.		
		overlay_raw.onAdd = function() {
			raw_data_layer = d3.select(this.getPanes().overlayMouseTarget).append("div")
																		  .attr("class", "rawpt");
			// Draw each marker as a separate SVG element.
			// We could use a single SVG, but what size would it have?
		};
		overlay_raw.draw = function() {
			var projection = this.getProjection(),
			padding = 10;

			var marker = raw_data_layer.selectAll("svg")
							  .data(d3.entries(raw_data))
							  .each(transform) // update existing markers
							  .enter().append("svg:svg")
							  .each(transform)
							  .attr("class", "marker");

			// Add a circle.
			marker.append("svg:circle")
				  .attr("r", 3.0)
				  .attr("cx", padding)
				  .attr("cy", padding);

			function transform(d) {
				d2 = new google.maps.LatLng(+d.value[9], +d.value[10]);
				//d2 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
				d2 = projection.fromLatLngToDivPixel(d2);
				return d3.select(this)
						 .style("left", (d2.x - padding) + "px")
						 .style("top", (d2.y - padding) + "px");
			}
		};
		overlay_raw.onRemove = function() {
			$(".rawpt").remove();
		};
        
		function loadPtsRaw() {
			overlay_raw.setMap(null);
			raw_data = null;
			raw_data_load_callback_count = selectedLines.length;
			
			for (i=0; i < selectedLines.length; i++) {
				d3.text("data_separated_by_line_and_day/"+selectedLines[i]+"/" + dateFile, function(text) {
					raw_data = d3.csv.parseRows(text);
					raw_data.shift();
					//do sampling
					var samplingRate = Math.floor(raw_data.length/maxPts);
					if (samplingRate < 1) {
						samplingRate = 1;
					}
					raw_data = raw_data.filter(function(row,index) { 
						if (index % samplingRate != 0) {
							return false;
						}
						return true;
					});
					
					//filter by start date
					raw_data = raw_data.filter(function(row,index) {
						var ts = new Date(row[11].substring(0, 19).replace(" ", "T")+ "+0000");
						
						if (startHour > +ts.getUTCHours()) {
							return false;
						}
						else if (startHour == +ts.getUTCHours()) {
						   if (startMinute > +ts.getUTCMinutes()) {
							   return false;
						   }
						}
						
						if (endHour < +ts.getUTCHours()) {
							return false;
						}
						else if (endHour == +ts.getUTCHours()) {
						   if (endMinute < +ts.getUTCMinutes()) {
							   return false;
						   }
						}
						
						return true;
					});   
	
					//select buses for temporal chart comparison. Select buses that are close to the start point of the outlier
					if (selectedOutlier != null)
					{
                        //select buses based on start latlong
						selectedBuses = {}
						for (idx in raw_data){
							var dist = Math.pow(Math.pow(+raw_data[idx][9] - selectedOutlier.LatStart,2) + Math.pow(+raw_data[idx][10] - selectedOutlier.LongStart, 2), 0.5);
							if (dist < MAX_DIST){
								selectedBuses[raw_data[idx][3]] = raw_data[idx][11]; //put start timestamp here 
							}
						}
                        //select buses based on end latlong
                        selectedBuses2 = {}
                        for (idx in raw_data){
                            if (raw_data[idx][3] in selectedBuses) {
							    var dist = Math.pow(Math.pow(+raw_data[idx][9] - selectedOutlier.LatEnd,2) + Math.pow(+raw_data[idx][10] - selectedOutlier.LongEnd, 2), 0.5);
							    if (dist < MAX_DIST){
                                    //put condition here to get only buses that folow the same direction of the outlier
                                    if (!(raw_data[idx][3] in selectedBuses2)){
							            selectedBuses2[raw_data[idx][3]] = [selectedBuses[raw_data[idx][3]], raw_data[idx][11]]; //put end timestamp along with start timestamp 
                                    }
							    }
                            }
						}
                        
						//filter by start date and end date of the bus
						data2 = {}; 

						for (idx in raw_data) {
							if (min_latitude_bounding == null || min_latitude_bounding > raw_data[idx][9])
								min_latitude_bounding = raw_data[idx][9];
							if (max_latitude_bounding == null || max_latitude_bounding < raw_data[idx][9])
								max_latitude_bounding = raw_data[idx][9];
							if (min_longitude_bounding == null || min_longitude_bounding > raw_data[idx][10])
								min_longitude_bounding = raw_data[idx][10];
							if (max_longitude_bounding == null || max_longitude_bounding < raw_data[idx][10])
								max_longitude_bounding = raw_data[idx][10];
								
							if (!(raw_data[idx][3] in selectedBuses2)) {
								continue;
							}
                            var startTime = new Date(selectedBuses2[raw_data[idx][3]][0].substring(0, 19).replace(" ", "T") + "+0000");
						    var endTime = new Date(selectedBuses2[raw_data[idx][3]][1].substring(0, 19).replace(" ", "T") + "+0000");
							var ts = new Date(raw_data[idx][11].substring(0, 19).replace(" ", "T") + "+0000");
						  
							if(+startTime.getUTCHours() > +ts.getUTCHours()) {
								continue;
							}
							else if (+startTime.getUTCHours() == +ts.getUTCHours()) {
								if (+startTime.getUTCMinutes() > +ts.getUTCMinutes()) {
									continue;
								}
							}
							
							if(+endTime.getUTCHours() < +ts.getUTCHours()) {
								continue;
							}
							else if (+endTime.getUTCHours() == +ts.getUTCHours()) {
								if (+endTime.getUTCMinutes() < +ts.getUTCMinutes()) {
									continue;
								}
							}
							if (!(raw_data[idx][3] in data2)) {
								data2[raw_data[idx][3]] = []
							}
                            item = {TimeStamp: raw_data[idx][11],
                                    TimeStampStart: selectedBuses2[raw_data[idx][3]][0],
                                    TimeStampEnd: selectedBuses2[raw_data[idx][3]][1],
                                    LatitudePonto: raw_data[idx][9],
                                    LongitudePonto: raw_data[idx][10],
                                   }
                            
							data2[raw_data[idx][3]].push(item);
						}
					}

					//add to the temporal chart
					for (var key in data2) {
						vis.append('svg:path')
						   .attr('d', lineGen(data2[key]))
						   .attr('stroke', 'blue')
						   .attr('stroke-width', 1)
						   .attr("class", "line")
						   .attr('fill', 'none');
					}
                    
                    raw_data_load_callback();
					//var overlay_raw = new google.maps.OverlayView();
					// Add the container when the overlay is added to the map.
					// Bind our overlay to the map…
				});
			}
			//overlay_raw.draw();
		}
		//var rectangle;
		var bounds = new google.maps.LatLngBounds();
		function raw_data_load_callback() {
			raw_data_load_callback_count = raw_data_load_callback_count - 1;
			if (raw_data_load_callback_count == 0)
				overlay_raw.setMap(map);
			
			
			bounds = new google.maps.LatLngBounds();
			bounds.extend(new google.maps.LatLng(+max_latitude_bounding, +max_longitude_bounding));
			bounds.extend(new google.maps.LatLng(+min_latitude_bounding, +min_longitude_bounding));
			map.setCenter(new google.maps.LatLng((+min_latitude_bounding + +max_latitude_bounding)/2, (+min_longitude_bounding + +max_longitude_bounding)/2));
			map.fitBounds(bounds);
			/*if (rectangle != null)
				rectangle.setMap(null);
			rectangle = new google.maps.Rectangle({
				strokeColor: '#FF0000',
				strokeOpacity: 0.8,
				strokeWeight: 2,
				fillColor: '#FF0000',
				fillOpacity: 0.35,
				map: map,
				bounds: new google.maps.LatLngBounds(
					new google.maps.LatLng(max_latitude_bounding, max_longitude_bounding),
					new google.maps.LatLng(min_latitude_bounding, min_longitude_bounding))
			});*/
		}
		
		overlay_outliers.onAdd = function() {
			//remove all previous layers.
			myNode = this.getPanes().overlayMouseTarget;
			while (myNode.firstChild) {
				myNode.removeChild(myNode.firstChild);
			}

			outlier_data_layer = d3.select(this.getPanes().overlayMouseTarget).append("div")
																 .attr("class", "outliers");
		};
		overlay_outliers.draw = function() {
			var projection = this.getProjection(),
			padding = 10;
			
			var tooltip = d3.select("body")
							.append("div")
							.style("position", "absolute")
							.style("z-index", "10")
							.style("visibility", "hidden")
							.text("a simple tooltip");
            
            var marker = outlier_data_layer.selectAll("svg")
										   .data(d3.entries(outlier_data))
										   .each(
											  function (d) {
												d = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
												d = projection.fromLatLngToDivPixel(d);
												return d3.select(this)
												  .style("left", (d.x - padding) + "px")
												  .style("top", (d.y - padding) + "px");
											  }
										   )
										   .enter().append("svg:svg")
										   .each(
											  function (d) {
												d = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
												d = projection.fromLatLngToDivPixel(d);
												return d3.select(this)
												  .style("left", (d.x - padding) + "px")
												  .style("top", (d.y - padding) + "px")
											  }
										   )
										   .attr("class", "marker");

			// Add a circle.
			marker.append("svg:circle")
				  //.attr("r", function(d) { return (3.0 + 5.0 * d.value['TimeStampPercentage']) })
				  .attr("r", 4.0)
				  .attr("cx", padding)
				  .attr("cy", padding)
				  .on("click", function(d, i) {
					  tooltip.style("visibility", "visible");
                      alert("Selected node:\n" +
                            "Start: " + d.value['TimeStampStart'] + "\n"+
                            "End:   " + d.value['TimeStampEnd'] + "\n"+
                            "Line: " + d.value['Line'] + "\n"+
                            "Bus Id: " + d.value['BusId']);					  
				  });
            
			//Add a label.
			/*marker.append("svg:text")
				  .attr("x", padding + 7)
				  .attr("y", padding)
				  .attr("dy", ".31em")
				  .text(function(d) { 
							//if (selectedLines[0] =="All") {
							//	return d.value['Line'];
							//}
							//else{
						    //return d.value['row'];
                            //}
								return "";
						});*/
            
            //if ($('#ConnectedPts').is(':checked') && (selectedLines[0] != "All")){
            //if (selectedLines[0] != "All"){
			if (selectedLines.length != 0) {
                //remove all lines
                $(".marker2").remove();
                var marker = outlier_data_layer.selectAll("svg2")
                                               .data(d3.entries(outlier_data))
                                               .each(
                                                  function (d) {
                                                    d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                    d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     var minx = Math.min(d1.x, d2.x);
                                                     var miny = Math.min(d1.y, d2.y);
                                                    return d3.select(this)
                                                      .style("left", (minx) + "px")
                                                      .style("top", (miny) + "px");
                                                  }
                                               )
                                               .enter().append("svg:svg")
                                               .each(
                                                  function (d) {
                                                    d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                    d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     var minx = Math.min(d1.x, d2.x);
                                                     var miny = Math.min(d1.y, d2.y);
                                                    return d3.select(this)
                                                      .style("left", (minx) + "px")
                                                      .style("top", (miny) + "px");
                                                  }
                                               )
                                               .attr("class", "marker2");
                marker.append("svg:line")
                      .style("stroke", "red") 
                      .style("stroke-width", 1) 
                      .attr("x1", 0)
                      .attr("y1", function (d) {     d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                    d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     if (d1.x>d2.x){
                                                         return d2.y - Math.min(d1.y,d2.y);
                                                     }else{
                                                         return d1.y - Math.min(d1.y,d2.y);
                                                     }
                                                  })
                      .attr("x2", function (d) {     d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                    d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     var minx = Math.min(d1.x, d2.x);
                                                     var maxx = Math.max(d1.x, d2.x);
                                                    return maxx-minx;
                                                  })
                      .attr("y2", function (d) {     d1 = new google.maps.LatLng(+d.value['LatitudePonto'], +d.value['LongitudePonto']);
                                                    d1 = projection.fromLatLngToDivPixel(d1);
                                                     d2 = new google.maps.LatLng(+d.value['LatitudePontoPrevious'], +d.value['LongitudePontoPrevious']); 
                                                     d2 = projection.fromLatLngToDivPixel(d2);
                                                     if (d1.x>d2.x){
                                                         return d1.y - Math.min(d1.y,d2.y);
                                                     }else{
                                                         return d2.y - Math.min(d1.y,d2.y);
                                                     }
                                                  });
            }
		};
    
		overlay_outliers.onRemove = function() {
			$(".outliers").remove();
		};

		function loadOutliersPerDay() {
			var barchart_data = [];
			d3.csv(outliersperdayfile, function(data) {
				data.forEach(function(d) {
					barchart_data.push({key: d.Date, number_of_outliers: d.NumberOfOutliers});
				});

				var barWidth = 40;
				var height = 179;

				var y = d3.scale.linear()
					.domain([0, d3.max(barchart_data, function(d) { return d.number_of_outliers*1.05; })])
					.range([0, height]);

				var chart = d3.select(".verticalBarchart")
								.attr("width", barWidth * barchart_data.length)
								.attr("height", height);

				var bar = chart.selectAll("g")
								.data(barchart_data)
								.enter().append("g")
								.attr("transform", function(d, i) { return "translate(" + i * barWidth + "," + (height - y(d.number_of_outliers)) + ")"; });

				bar.append("rect")
					.attr("height",  function(d) { return y(d.number_of_outliers); })
					.attr("width", barWidth - 1)
					.on("click", function(d, i) {
									d3.select(".vselected").style({fill: "steelblue"});
									d3.select(".vselected").classed("vselected", false);
									d3.select(this).classed("vselected", true);
									d3.select(this).style({fill: 'red'});
                  fields = d.key.split("/");
									dateFile = fields[1] + "-" + fields[0] + "-2013_sorted_with_speed";
                  outliersfile = fields[1] + "_" + fields[0] + ".csv";
									loadLstboxFromOutliers();
                   
								 })
					.on("mouseover", function(d, i) {
										d3.select(this).style({opacity: '0.6'});
										})
					.on("mouseout", function(d, i) {
										d3.select(this).style({opacity: '1.0'});
									 });

				bar.append("text")
					.attr("x", barWidth / 2)
					.attr("y", function (d) { y(d.number_of_outliers); })
					.attr("dx", "1em")
					.attr("transform", function(d) { return "translate(0, " + (y(d.number_of_outliers) - 3) + ")"; })
					.text(function(d) { return d.key; })
					.on("click", function(d, i) {
                  fields = d.key.split("/");
									dateFile = fields[1] + "-" + fields[0] +  "-2013_sorted_with_speed";
                  outliersfile = fields[1] + "_" + fields[0] + ".csv";
									loadLstboxFromOutliers();
								 });

				
				bar.append("text")
					.attr("x", barWidth / 2)
					.attr("y", function (d) { y(d.number_of_outliers); })
					.attr("dx", ".8em")
					//.attr("transform", function(d) { return "translate(0, " + 12 + ")"; })
					.text(function(d) { return d.number_of_outliers; })
					.on("click", function(d, i) {
                  fields = d.key.split("/");
									dateFile = fields[1] + "-" + fields[0] + "-2013_sorted_with_speed";
                  outliersfile = fields[1] + "_" + fields[0] + ".csv";
									loadLstboxFromOutliers();
								 });

			});
		}
			
		function loadPtsOutliers() {
			overlay_outliers.setMap(null);
			outlier_data = null;
			
			min_latitude_bounding = null;
			max_latitude_bounding = null;
			min_longitude_bounding = null;
			max_longitude_bounding = null;

			d3.csv(outliersfile, function(data) {
				data = data.filter(function(row,index) {
					var contains = false;
					if (selectedLines.length == 0)
						contains = true;
					for (i in selectedLines) {
						if (row['Linha'] == selectedLines[i]) {
							contains = true;
						}
						//if (selectedLines[i] == "All") {
						//	contains = true;
						//}
					}
					
					return contains;
				});
				outlier_data = [];
				var lines_outliers = {};  
				k = 0;
				//pts must be structured as rows
				for (row in data) {
					var minreftime = parseDate(data[row]['TimeStamp_19']); 
					var maxreftime = parseDate(data[row]['TimeStamp_0']); 
                    //console.log("starttime: " + data[row]['TimeStamp_19']);
                    //console.log("endtime: " + data[row]['TimeStamp_0']);
                    
					for (i = 0; i<20; i++){
						var timestamp = parseDate(data[row]['TimeStamp_' + i]);
                      
                        if (i>=1){
                            var TimeStampPrevious = data[row]['TimeStamp_'+(i-1)];
                            var LatPrevious = data[row]['LatitudePonto_'+(i-1)];
                            var LongPrevious = data[row]['LongitudePonto_'+(i-1)];
                        }else{
                            var TimeStampPrevious = data[row]['TimeStamp_'+i];
                            var LatPrevious = data[row]['LatitudePonto_'+i];
                            var LongPrevious = data[row]['LongitudePonto_'+i];
                        }
						outlier_data[k] = {
							TimeStampPercentage: (timestamp - minreftime) / (maxreftime-minreftime), 
							TimeStampStart:data[row]['TimeStamp_19'].substring(0, 19),
							TimeStampEnd:data[row]['TimeStamp_0'].substring(0, 19),
							TimeStamp:data[row]['TimeStamp_'+i],
							LatitudePonto:data[row]['LatitudePonto_'+i],
                            LatStart:data[row]['LatitudePonto_19'],
                            LongStart:data[row]['LongitudePonto_19'],
                            LatEnd:data[row]['LatitudePonto_0'],
                            LongEnd:data[row]['LongitudePonto_0'],
							LongitudePonto:data[row]['LongitudePonto_'+i],
                             TimeStampPrevious: TimeStampPrevious,
							LatitudePontoPrevious:LatPrevious,
							LongitudePontoPrevious:LongPrevious,
							row:row,
							BusId:data[row]["Onibus"],
							Line:data[row]["Linha"]
						};
						if (min_latitude_bounding == null || min_latitude_bounding > outlier_data[k]['LatitudePonto'])
							min_latitude_bounding = outlier_data[k]['LatitudePonto'];
						if (max_latitude_bounding == null || max_latitude_bounding < outlier_data[k]['LatitudePonto'])
							max_latitude_bounding = outlier_data[k]['LatitudePonto'];
						if (min_longitude_bounding == null || min_longitude_bounding > outlier_data[k]['LongitudePonto'])
							min_longitude_bounding = outlier_data[k]['LongitudePonto'];
						if (max_longitude_bounding == null || max_longitude_bounding < outlier_data[k]['LongitudePonto'])
							max_longitude_bounding = outlier_data[k]['LongitudePonto'];
						k = k + 1;
					} 
				}
		   
				//do sampling
				var samplingRate = Math.floor(outlier_data.length/maxPts);

				if (samplingRate < 1){
					samplingRate = 1;
				}
				outlier_data = outlier_data.filter(function(row,index) { 
					if (index % samplingRate != 0) {
						return false;
					}
					return true;
				}); 
			
				//filter by start date
				outlier_data = outlier_data.filter(function(row,index) {
					var ts = new Date(row["TimeStamp"].substring(0, 19).replace(" ", "T")+ "+0000");
					if (startHour > +ts.getUTCHours()) {
						return false;
					}
					else if (startHour == +ts.getUTCHours()) {
						if (startMinute > +ts.getUTCMinutes()) {
							return false;
						}
					}
					
					if(endHour < +ts.getUTCHours()) {
						return false;
					}
					else if (endHour == +ts.getUTCHours()) {
					   if (endMinute< +ts.getUTCMinutes()) {
						   return false;
					   }
					}
					return true;
				});
                
                selectedOutlier = outlier_data[0]; //set the selected outlier var with the first point of the first outlier. Its timestamp and coordinates will be used so select raw points in the temporal chart
                
                //remove duplicated outliers
                var startTimeAbs = new Date(selectedOutlier.TimeStampStart.substring(0, 19).replace(" ", "T")+ "+0000");
                var endTimeAbs = new Date(selectedOutlier.TimeStampEnd.substring(0, 19).replace(" ", "T")+ "+0000");
                var startTime = new Date(2000, 0, 0, startTimeAbs.getHours(), startTimeAbs.getMinutes(), 0, 0);
                var endTime = new Date(2000, 0, 0, endTimeAbs.getHours(), endTimeAbs.getMinutes(), 0, 0);
                outlier_data_by_bus = {};
                outlier_data_by_bus2 = {};
                
                for (row in outlier_data) {
                    //temporary: select pts only for the selected outlier 
                    if (outlier_data[row]["BusId"] == selectedOutlier["BusId"]){
                        if (!((outlier_data[row]["BusId"]+outlier_data[row]["TimeStamp"]) in outlier_data_by_bus)){
                              outlier_data_by_bus[outlier_data[row]["BusId"]+outlier_data[row]["TimeStamp"]] = 1;
                              if (!(outlier_data[row]["BusId"] in outlier_data_by_bus2)){
                                  outlier_data_by_bus2[outlier_data[row]["BusId"]] = [];
                              }
                              outlier_data_by_bus2[outlier_data[row]["BusId"]].push(outlier_data[row]);

                              //update start and end dates of the selected outlier    
                              var tsAbs = new Date(outlier_data[row]["TimeStamp"].substring(0, 19).replace(" ", "T")+ "+0000");
                              var ts = new Date(2000, 0, 0, tsAbs.getHours(), tsAbs.getMinutes(), 0, 0);
                          
                              if (ts <= startTime){
                                  startTime = ts;
                                  selectedOutlier.TimeStampStart = outlier_data[row]["TimeStamp"];
                                  selectedOutlier.LatStart = outlier_data[row]["LatitudePonto"];
                                  selectedOutlier.LongStart = outlier_data[row]["LongitudePonto"];
                              }
                              if (ts >= endTime){
                                  endTime = ts;
                                  selectedOutlier.TimeStampEnd = outlier_data[row]["TimeStamp"];
                                  selectedOutlier.LatEnd = outlier_data[row]["LatitudePonto"];
                                  selectedOutlier.LongEnd = outlier_data[row]["LongitudePonto"];
                              }
                        }
                    }    
				}
         
          		//add to the temporal chart
                for (key in outlier_data_by_bus2){
                    vis.append('svg:path')
                      .attr('d', lineGen(outlier_data_by_bus2[key]))
                      .attr('stroke', 'red')
                      .attr('stroke-width', 3)
                      .attr("class", "line")
                      .attr('fill', 'none');
                }
                
				overlay_outliers.setMap(map);
			});
		}
		
		function sortByNumberOfOutliers(a, b) 
		{
			if (a.number_of_outliers < b.number_of_outliers)
				return 1;
			if (a.number_of_outliers > b.number_of_outliers)
				return -1;
			
			return 0;
		}
		
		function sortByLabel(a, b)
		{
			var temp_a = Number(a.key);
			var temp_b = Number(b.key);
			
			if (temp_a < temp_b)
				return -1;
			if (temp_a > temp_b)
				return 1;
			
			return 0;
		}
	
		function changeSortLineBarChart()
		{
			if (sortLineBarChartByNumberOfOutliers)
				sortLineBarChartByNumberOfOutliers = false;
			else
				sortLineBarChartByNumberOfOutliers = true;
			
			loadLstboxFromOutliers();
		}
	
		function loadLstboxFromOutliers() {
            //first, remove all existing bars in the bar chart
            d3.select(".barchart").selectAll("g").remove();
            
            //select all outliers for the selected day
            //selectedLines = ["All"];
			selectedLines = [];
            loadPts();
            
			d3.csv(outliersfile, function(data) {
				var data2 = [];
				var lines_outliers = {};
				var lines_outliers_total = {};
				for (row in data){
					if (!(+data[row]['Linha'] in lines_outliers)) {
						lines_outliers[data[row]['Linha']] = {};
					}                                                                                                                                                                                                

                    lines_outliers[+data[row]['Linha']][data[row]['Onibus']] = 1; //add bus
					lines_outliers_total[(+data[row]['Linha']) + "_" + data[row]['Onibus']] = 1;
				}
				
				var barchart_data = [];
				var max = 0;
                //first remove previous bars
            
                for (line in lines_outliers)
				{
        	        barchart_data.push({key: line, number_of_outliers: Object.keys(lines_outliers[line]).length});
					if (Object.keys(lines_outliers[line]).length > max)
						max = Object.keys(lines_outliers[line]).length;
				}
				
				if (sortLineBarChartByNumberOfOutliers)
					barchart_data.sort(sortByNumberOfOutliers);
				else
					barchart_data.sort(sortByLabel);
                
				//add "All"
				var width = 280,//420
					barHeight = 20;

				var x = d3.scale.linear()
					.domain([0, d3.max(barchart_data, function(d) { return d.number_of_outliers; })])
					.range([0, width]);
           
				var chart = d3.select(".barchart")
					.attr("width", width)
					.attr("height", barHeight * barchart_data.length);
                
				var bar = chart.selectAll("g")
					.data(barchart_data)
				    .enter().append("g")
					.attr("transform", function(d, i) { return "translate(0," + i * barHeight + ")"; });

				bar.append("rect")
					.attr("width",  function(d) { return Math.max(45, x(d.number_of_outliers)); })
					.attr("height", barHeight - 1)
					.on("click", function(d, i) {
									d3.select(".selected").style({fill: "steelblue"});
									d3.select(".selected").classed("selected", false);

									d3.select(this).classed("selected", true);
									d3.select(this).style({fill: 'red'});
									selectedLines = [d.key];
									loadPts();
								 })
					.on("mouseover", function(d, i) {
										d3.select(this).style({opacity: '0.6'});
										})
					.on("mouseout", function(d, i) {
										d3.select(this).style({opacity: '1.0'});
									 });

				bar.append("text")
					.attr("x", function(d) { return (d.key).length * 5.5 + 2; })
					.attr("y", barHeight / 2)
					.attr("dy", ".35em")
					.text(function(d) { return d.key; })
					.on("click", function(d, i) {
									selectedLines = [d.key];
									loadPts();
								 });

				bar.append("text")
					.attr("x", function(d) { return Math.max(42, x(d.number_of_outliers) - 3); })
					.attr("y", barHeight / 2)
					.attr("dy", ".35em")
					.text(function(d) { return d.number_of_outliers; })
					.on("click", function(d, i) {
									selectedLines = [d.key];
									loadPts();
								 });
									
			});
		}
		function format2digits(n){
            return n > 9 ? "" + n: "0" + n;
        }
		function loadPts() {
			var lstbox = document.getElementById("lstbox_lines");
			//remove all existing lines in the temporal chart
			vis.selectAll("path.line").remove();
            $(".marker2").remove();

			/*var startTime = document.getElementById("inputStartTime").value;
			startHour = Math.floor(startTime/60);
			startMinute = (startTime%60)
			document.getElementById("valueStartTime").innerHTML = format2digits(startHour) + ":" + format2digits(startMinute);

			var timeRange = document.getElementById("inputTimeRange").value;
			rangeHour = Math.floor(timeRange/60);
			rangeMinute = (timeRange%60)
			document.getElementById("valueTimeRange").innerHTML = format2digits(rangeHour) + ":" + format2digits(rangeMinute);*/

			loadPtsOutliers();
			loadPtsRaw();	  
		}
        
        //force reset of slide bars
        //document.getElementById("inputStartTime").value = 0;
        //document.getElementById("inputTimeRange").value = 1439;
        //initalize canvastime
        var canvas = initCanvas('canvastime');
        var rect1x = 10;
        var rect2x = canvas.width-10;
        var selrect = -1;
        canvas.update = function(g) {
            this.g = g; // so the drawLine method will know where to draw to.
            
            //check if clicked on rectangle 1 or 2
            if (this.cursor.x > rect1x-10 && this.cursor.x < rect1x+10  && this.cursor.z==1){
                selrect = 1;
            }
            else if (this.cursor.x > rect2x-10 && this.cursor.x < rect2x+10  && this.cursor.z==1){
                selrect = 2;
            }
            //else if (this.cursor.x > rect1x+10 && this.cursor.x < rect2x-10  && this.cursor.z==1){
            //    selrect = 3;
            //}
            
            if ( this.cursor.z==0 ){
                selrect = -1;
            }
            
            if (selrect==1){
                rect1x = Math.max(10,this.cursor.x);
            }
            else if (selrect==2){
                rect2x = Math.min(canvas.width-10,this.cursor.x);
            }
            //else if (selrect==3){
            //    var range = rect2x-rect1x;
            //    rect1x = Math.max(10,this.cursor.x-(range/2));
            //    rect2x = Math.min(canvas.width-10,this.cursor.x+(range/2));
            //}
            
            //if the rectangles are too close, put them apart
            if (rect2x-rect1x<40){
                rect2x = Math.min(canvas.width-10,rect1x+40);
            }
            
            //draw rectangle 1 and 2
            g.fillStyle="black";
            g.fillRect(rect1x-10,0,20,this.height);
            g.fillRect(rect2x-10,0,20,this.height);
            
            g.fillStyle="lightgreen";
            g.fillRect(rect1x+10,0,rect2x-rect1x-20,this.height);
            
            var startTime = 1439*(rect1x-10)/this.width;
			startHour = Math.floor(startTime/60);
			startMinute = Math.floor(startTime%60);
			document.getElementById("valStartTime").innerHTML = format2digits(startHour) + ":" + format2digits(startMinute);
            
            var endTime = 1439*(rect2x+10)/this.width;
			endHour = Math.floor(endTime/60);
			endMinute = Math.floor(endTime%60);
			document.getElementById("valEndTime").innerHTML = format2digits(endHour) + ":" + format2digits(endMinute);
            
        }    
		loadOutliersPerDay();
		loadLstboxFromOutliers();
    </script>
</html>
